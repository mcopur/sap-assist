
--- Start of README.md ---
# SAP Assist

SAP systems integrated, AI-powered business assistant

## Description

SAP Assist is a comprehensive solution designed to streamline interactions with SAP systems through natural language processing and intelligent automation. It provides an intuitive interface for managing leave requests, purchase orders, and other common SAP-related tasks.

## Features

- Natural language processing for user queries
- Integration with SAP systems
- Leave management
- Purchase order processing
- Automated reporting

## Getting Started

Instructions for setting up the project locally will be added soon.

## License

This project is licensed under the MIT License - see the LICENSE file for details.
--- End of README.md ---

--- Start of c.py ---
import os
from pathlib import Path

# List of folders to exclude (dependencies, builds, etc.)
excluded_dirs = ['node_modules', 'venv', '.git', 'dist',
                 'build', 'vendor', 'bin', 'out', '__pycache__']

# List of file extensions to include
included_extensions = [
    # Go
    '.go', '.mod', '.sum',
    # Python
    '.py', 'requirements.txt', 'Pipfile', 'pyproject.toml', '.json'
    # React (JavaScript, TypeScript)
    '.js', '.jsx', '.ts', '.tsx', 'package.json',
    # General (Markdown, YAML, HTML, CSS)
    '.md', '.yaml', '.yml', '.html', '.css'
]


def load_gitignore_patterns():
    gitignore_path = Path(".gitignore")
    if gitignore_path.exists():
        with open(gitignore_path, "r", encoding="utf-8") as f:
            patterns = [line.strip() for line in f if line.strip()
                        and not line.startswith("#")]
        return patterns
    return []


def is_ignored(filepath, patterns):
    try:
        relative_filepath = filepath.relative_to(Path.cwd())
    except ValueError:
        return False
    for pattern in patterns:
        if relative_filepath.match(pattern):
            return True
    return False


# Define the directory containing your files
root_dir = "."

# Load gitignore patterns
ignore_patterns = load_gitignore_patterns()

# Open a new text file to write the combined contents
with open("source.txt", "w", encoding="utf-8") as outfile:
    # Walk through all directories and files
    for subdir, dirs, files in os.walk(root_dir):
        # Skip excluded directories
        dirs[:] = [d for d in dirs if d not in excluded_dirs]

        for file in files:
            filepath = Path(subdir) / file
            # Check if the file has the correct extension and is not ignored
            if any(str(filepath).endswith(ext) for ext in included_extensions) and not is_ignored(filepath, ignore_patterns):
                try:
                    with open(filepath, "r", encoding="utf-8") as infile:
                        outfile.write(f"\n--- Start of {filepath} ---\n")
                        outfile.write(infile.read())
                        outfile.write(f"\n--- End of {filepath} ---\n")
                except Exception as e:
                    pass  # Skip unreadable files

--- End of c.py ---

--- Start of backend/go.mod ---
module github.com/mcopur/sap-assist

go 1.22.1

require (
	github.com/cespare/xxhash/v2 v2.2.0 // indirect
	github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f // indirect
	github.com/pkg/errors v0.9.1 // indirect
)

require (
	github.com/KyleBanks/depth v1.2.1 // indirect
	github.com/felixge/httpsnoop v1.0.4 // indirect
	github.com/gabriel-vasile/mimetype v1.4.3 // indirect
	github.com/go-openapi/jsonpointer v0.21.0 // indirect
	github.com/go-openapi/jsonreference v0.21.0 // indirect
	github.com/go-openapi/spec v0.21.0 // indirect
	github.com/go-openapi/swag v0.23.0 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/go-playground/validator/v10 v10.22.0
	github.com/go-redis/redis/v8 v8.11.5
	github.com/google/uuid v1.6.0
	github.com/gorilla/handlers v1.5.2
	github.com/gorilla/mux v1.8.1
	github.com/jackc/chunkreader/v2 v2.0.1 // indirect
	github.com/jackc/pgconn v1.14.3 // indirect
	github.com/jackc/pgio v1.0.0 // indirect
	github.com/jackc/pgpassfile v1.0.0 // indirect
	github.com/jackc/pgproto3/v2 v2.3.3 // indirect
	github.com/jackc/pgservicefile v0.0.0-20221227161230-091c0ba34f0a // indirect
	github.com/jackc/pgtype v1.14.0 // indirect
	github.com/jackc/pgx/v4 v4.18.3
	github.com/jackc/puddle v1.3.0 // indirect
	github.com/joho/godotenv v1.5.1
	github.com/josharian/intern v1.0.0 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/lib/pq v1.10.9 // indirect
	github.com/mailru/easyjson v0.7.7 // indirect
	github.com/swaggo/files v1.0.1 // indirect
	github.com/swaggo/http-swagger v1.3.4
	github.com/swaggo/swag v1.16.3 // indirect
	golang.org/x/crypto v0.25.0 // indirect
	golang.org/x/net v0.27.0 // indirect
	golang.org/x/sys v0.22.0 // indirect
	golang.org/x/text v0.16.0 // indirect
	golang.org/x/time v0.5.0
	golang.org/x/tools v0.23.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)

--- End of backend/go.mod ---

--- Start of backend/go.sum ---
github.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=
github.com/KyleBanks/depth v1.2.1 h1:5h8fQADFrWtarTdtDudMmGsC7GPbOAu6RVB3ffsVFHc=
github.com/KyleBanks/depth v1.2.1/go.mod h1:jzSb9d0L43HxTQfT+oSA1EEp2q+ne2uh6XgeJcm8brE=
github.com/Masterminds/semver/v3 v3.1.1/go.mod h1:VPu/7SZ7ePZ3QOrcuXROw5FAcLl4a0cBrbBpGY/8hQs=
github.com/cespare/xxhash/v2 v2.2.0 h1:DC2CZ1Ep5Y4k3ZQ899DldepgrayRUGE6BBZ/cd9Cj44=
github.com/cespare/xxhash/v2 v2.2.0/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=
github.com/cockroachdb/apd v1.1.0 h1:3LFP3629v+1aKXU5Q37mxmRxX/pIu1nijXydLShEq5I=
github.com/cockroachdb/apd v1.1.0/go.mod h1:8Sl8LxpKi29FqWXR16WEFZRNSz3SoPzUzeMeY4+DwBQ=
github.com/coreos/go-systemd v0.0.0-20190321100706-95778dfbb74e/go.mod h1:F5haX7vjVVG0kc13fIWeqUViNPyEJxv/OmvnBo0Yme4=
github.com/coreos/go-systemd v0.0.0-20190719114852-fd7a80b32e1f/go.mod h1:F5haX7vjVVG0kc13fIWeqUViNPyEJxv/OmvnBo0Yme4=
github.com/creack/pty v1.1.7/go.mod h1:lj5s0c3V2DBrqTV7llrYr5NG6My20zk30Fl46Y7DoTY=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f h1:lO4WD4F/rVNCu3HqELle0jiPLLBs70cWOduZpkS1E78=
github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f/go.mod h1:cuUVRXasLTGF7a8hSLbxyZXjz+1KgoB3wDUb6vlszIc=
github.com/felixge/httpsnoop v1.0.4 h1:NFTV2Zj1bL4mc9sqWACXbQFVBBg2W3GPvqp8/ESS2Wg=
github.com/felixge/httpsnoop v1.0.4/go.mod h1:m8KPJKqk1gH5J9DgRY2ASl2lWCfGKXixSwevea8zH2U=
github.com/fsnotify/fsnotify v1.4.9 h1:hsms1Qyu0jgnwNXIxa+/V/PDsU6CfLf6CNO8H7IWoS4=
github.com/fsnotify/fsnotify v1.4.9/go.mod h1:znqG4EE+3YCdAaPaxE2ZRY/06pZUdp0tY4IgpuI1SZQ=
github.com/gabriel-vasile/mimetype v1.4.3 h1:in2uUcidCuFcDKtdcBxlR0rJ1+fsokWf+uqxgUFjbI0=
github.com/gabriel-vasile/mimetype v1.4.3/go.mod h1:d8uq/6HKRL6CGdk+aubisF/M5GcPfT7nKyLpA0lbSSk=
github.com/go-kit/log v0.1.0/go.mod h1:zbhenjAZHb184qTLMA9ZjW7ThYL0H2mk7Q6pNt4vbaY=
github.com/go-logfmt/logfmt v0.5.0/go.mod h1:wCYkCAKZfumFQihp8CzCvQ3paCTfi41vtzG1KdI/P7A=
github.com/go-openapi/jsonpointer v0.21.0 h1:YgdVicSA9vH5RiHs9TZW5oyafXZFc6+2Vc1rr/O9oNQ=
github.com/go-openapi/jsonpointer v0.21.0/go.mod h1:IUyH9l/+uyhIYQ/PXVA41Rexl+kOkAPDdXEYns6fzUY=
github.com/go-openapi/jsonreference v0.21.0 h1:Rs+Y7hSXT83Jacb7kFyjn4ijOuVGSvOdF2+tg1TRrwQ=
github.com/go-openapi/jsonreference v0.21.0/go.mod h1:LmZmgsrTkVg9LG4EaHeY8cBDslNPMo06cago5JNLkm4=
github.com/go-openapi/spec v0.21.0 h1:LTVzPc3p/RzRnkQqLRndbAzjY0d0BCL72A6j3CdL9ZY=
github.com/go-openapi/spec v0.21.0/go.mod h1:78u6VdPw81XU44qEWGhtr982gJ5BWg2c0I5XwVMotYk=
github.com/go-openapi/swag v0.23.0 h1:vsEVJDUo2hPJ2tu0/Xc+4noaxyEffXNIs3cOULZ+GrE=
github.com/go-openapi/swag v0.23.0/go.mod h1:esZ8ITTYEsH1V2trKHjAN8Ai7xHb8RV+YSZ577vPjgQ=
github.com/go-playground/assert/v2 v2.2.0 h1:JvknZsQTYeFEAhQwI4qEt9cyV5ONwRHC+lYKSsYSR8s=
github.com/go-playground/assert/v2 v2.2.0/go.mod h1:VDjEfimB/XKnb+ZQfWdccd7VUvScMdVu0Titje2rxJ4=
github.com/go-playground/locales v0.14.1 h1:EWaQ/wswjilfKLTECiXz7Rh+3BjFhfDFKv/oXslEjJA=
github.com/go-playground/locales v0.14.1/go.mod h1:hxrqLVvrK65+Rwrd5Fc6F2O76J/NuW9t0sjnWqG1slY=
github.com/go-playground/universal-translator v0.18.1 h1:Bcnm0ZwsGyWbCzImXv+pAJnYK9S473LQFuzCbDbfSFY=
github.com/go-playground/universal-translator v0.18.1/go.mod h1:xekY+UJKNuX9WP91TpwSH2VMlDf28Uj24BCp08ZFTUY=
github.com/go-playground/validator/v10 v10.22.0 h1:k6HsTZ0sTnROkhS//R0O+55JgM8C4Bx7ia+JlgcnOao=
github.com/go-playground/validator/v10 v10.22.0/go.mod h1:dbuPbCMFw/DrkbEynArYaCwl3amGuJotoKCe95atGMM=
github.com/go-redis/redis/v8 v8.11.5 h1:AcZZR7igkdvfVmQTPnu9WE37LRrO/YrBH5zWyjDC0oI=
github.com/go-redis/redis/v8 v8.11.5/go.mod h1:gREzHqY1hg6oD9ngVRbLStwAWKhA0FEgq8Jd4h5lpwo=
github.com/go-stack/stack v1.8.0/go.mod h1:v0f6uXyyMGvRgIKkXu+yp6POWl0qKG85gN/melR3HDY=
github.com/gofrs/uuid v4.0.0+incompatible h1:1SD/1F5pU8p29ybwgQSwpQk+mwdRrXCYuPhW6m+TnJw=
github.com/gofrs/uuid v4.0.0+incompatible/go.mod h1:b2aQJv3Z4Fp6yNu3cdSllBxTCLRxnplIgP/c0N/04lM=
github.com/google/renameio v0.1.0/go.mod h1:KWCgfxg9yswjAJkECMjeO8J8rahYeXnNhOm40UhjYkI=
github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/gorilla/handlers v1.5.2 h1:cLTUSsNkgcwhgRqvCNmdbRWG0A3N4F+M2nWKdScwyEE=
github.com/gorilla/handlers v1.5.2/go.mod h1:dX+xVpaxdSw+q0Qek8SSsl3dfMk3jNddUkMzo0GtH0w=
github.com/gorilla/mux v1.8.1 h1:TuBL49tXwgrFYWhqrNgrUNEY92u81SPhu7sTdzQEiWY=
github.com/gorilla/mux v1.8.1/go.mod h1:AKf9I4AEqPTmMytcMc0KkNouC66V3BtZ4qD5fmWSiMQ=
github.com/jackc/chunkreader v1.0.0/go.mod h1:RT6O25fNZIuasFJRyZ4R/Y2BbhasbmZXF9QQ7T3kePo=
github.com/jackc/chunkreader/v2 v2.0.0/go.mod h1:odVSm741yZoC3dpHEUXIqA9tQRhFrgOHwnPIn9lDKlk=
github.com/jackc/chunkreader/v2 v2.0.1 h1:i+RDz65UE+mmpjTfyz0MoVTnzeYxroil2G82ki7MGG8=
github.com/jackc/chunkreader/v2 v2.0.1/go.mod h1:odVSm741yZoC3dpHEUXIqA9tQRhFrgOHwnPIn9lDKlk=
github.com/jackc/pgconn v0.0.0-20190420214824-7e0022ef6ba3/go.mod h1:jkELnwuX+w9qN5YIfX0fl88Ehu4XC3keFuOJJk9pcnA=
github.com/jackc/pgconn v0.0.0-20190824142844-760dd75542eb/go.mod h1:lLjNuW/+OfW9/pnVKPazfWOgNfH2aPem8YQ7ilXGvJE=
github.com/jackc/pgconn v0.0.0-20190831204454-2fabfa3c18b7/go.mod h1:ZJKsE/KZfsUgOEh9hBm+xYTstcNHg7UPMVJqRfQxq4s=
github.com/jackc/pgconn v1.8.0/go.mod h1:1C2Pb36bGIP9QHGBYCjnyhqu7Rv3sGshaQUvmfGIB/o=
github.com/jackc/pgconn v1.9.0/go.mod h1:YctiPyvzfU11JFxoXokUOOKQXQmDMoJL9vJzHH8/2JY=
github.com/jackc/pgconn v1.9.1-0.20210724152538-d89c8390a530/go.mod h1:4z2w8XhRbP1hYxkpTuBjTS3ne3J48K83+u0zoyvg2pI=
github.com/jackc/pgconn v1.14.3 h1:bVoTr12EGANZz66nZPkMInAV/KHD2TxH9npjXXgiB3w=
github.com/jackc/pgconn v1.14.3/go.mod h1:RZbme4uasqzybK2RK5c65VsHxoyaml09lx3tXOcO/VM=
github.com/jackc/pgio v1.0.0 h1:g12B9UwVnzGhueNavwioyEEpAmqMe1E/BN9ES+8ovkE=
github.com/jackc/pgio v1.0.0/go.mod h1:oP+2QK2wFfUWgr+gxjoBH9KGBb31Eio69xUb0w5bYf8=
github.com/jackc/pgmock v0.0.0-20190831213851-13a1b77aafa2/go.mod h1:fGZlG77KXmcq05nJLRkk0+p82V8B8Dw8KN2/V9c/OAE=
github.com/jackc/pgmock v0.0.0-20201204152224-4fe30f7445fd/go.mod h1:hrBW0Enj2AZTNpt/7Y5rr2xe/9Mn757Wtb2xeBzPv2c=
github.com/jackc/pgmock v0.0.0-20210724152146-4ad1a8207f65 h1:DadwsjnMwFjfWc9y5Wi/+Zz7xoE5ALHsRQlOctkOiHc=
github.com/jackc/pgmock v0.0.0-20210724152146-4ad1a8207f65/go.mod h1:5R2h2EEX+qri8jOWMbJCtaPWkrrNc7OHwsp2TCqp7ak=
github.com/jackc/pgpassfile v1.0.0 h1:/6Hmqy13Ss2zCq62VdNG8tM1wchn8zjSGOBJ6icpsIM=
github.com/jackc/pgpassfile v1.0.0/go.mod h1:CEx0iS5ambNFdcRtxPj5JhEz+xB6uRky5eyVu/W2HEg=
github.com/jackc/pgproto3 v1.1.0/go.mod h1:eR5FA3leWg7p9aeAqi37XOTgTIbkABlvcPB3E5rlc78=
github.com/jackc/pgproto3/v2 v2.0.0-alpha1.0.20190420180111-c116219b62db/go.mod h1:bhq50y+xrl9n5mRYyCBFKkpRVTLYJVWeCc+mEAI3yXA=
github.com/jackc/pgproto3/v2 v2.0.0-alpha1.0.20190609003834-432c2951c711/go.mod h1:uH0AWtUmuShn0bcesswc4aBTWGvw0cAxIJp+6OB//Wg=
github.com/jackc/pgproto3/v2 v2.0.0-rc3/go.mod h1:ryONWYqW6dqSg1Lw6vXNMXoBJhpzvWKnT95C46ckYeM=
github.com/jackc/pgproto3/v2 v2.0.0-rc3.0.20190831210041-4c03ce451f29/go.mod h1:ryONWYqW6dqSg1Lw6vXNMXoBJhpzvWKnT95C46ckYeM=
github.com/jackc/pgproto3/v2 v2.0.6/go.mod h1:WfJCnwN3HIg9Ish/j3sgWXnAfK8A9Y0bwXYU5xKaEdA=
github.com/jackc/pgproto3/v2 v2.1.1/go.mod h1:WfJCnwN3HIg9Ish/j3sgWXnAfK8A9Y0bwXYU5xKaEdA=
github.com/jackc/pgproto3/v2 v2.3.3 h1:1HLSx5H+tXR9pW3in3zaztoEwQYRC9SQaYUHjTSUOag=
github.com/jackc/pgproto3/v2 v2.3.3/go.mod h1:WfJCnwN3HIg9Ish/j3sgWXnAfK8A9Y0bwXYU5xKaEdA=
github.com/jackc/pgservicefile v0.0.0-20200714003250-2b9c44734f2b/go.mod h1:vsD4gTJCa9TptPL8sPkXrLZ+hDuNrZCnj29CQpr4X1E=
github.com/jackc/pgservicefile v0.0.0-20221227161230-091c0ba34f0a h1:bbPeKD0xmW/Y25WS6cokEszi5g+S0QxI/d45PkRi7Nk=
github.com/jackc/pgservicefile v0.0.0-20221227161230-091c0ba34f0a/go.mod h1:5TJZWKEWniPve33vlWYSoGYefn3gLQRzjfDlhSJ9ZKM=
github.com/jackc/pgtype v0.0.0-20190421001408-4ed0de4755e0/go.mod h1:hdSHsc1V01CGwFsrv11mJRHWJ6aifDLfdV3aVjFF0zg=
github.com/jackc/pgtype v0.0.0-20190824184912-ab885b375b90/go.mod h1:KcahbBH1nCMSo2DXpzsoWOAfFkdEtEJpPbVLq8eE+mc=
github.com/jackc/pgtype v0.0.0-20190828014616-a8802b16cc59/go.mod h1:MWlu30kVJrUS8lot6TQqcg7mtthZ9T0EoIBFiJcmcyw=
github.com/jackc/pgtype v1.8.1-0.20210724151600-32e20a603178/go.mod h1:C516IlIV9NKqfsMCXTdChteoXmwgUceqaLfjg2e3NlM=
github.com/jackc/pgtype v1.14.0 h1:y+xUdabmyMkJLyApYuPj38mW+aAIqCe5uuBB51rH3Vw=
github.com/jackc/pgtype v1.14.0/go.mod h1:LUMuVrfsFfdKGLw+AFFVv6KtHOFMwRgDDzBt76IqCA4=
github.com/jackc/pgx/v4 v4.0.0-20190420224344-cc3461e65d96/go.mod h1:mdxmSJJuR08CZQyj1PVQBHy9XOp5p8/SHH6a0psbY9Y=
github.com/jackc/pgx/v4 v4.0.0-20190421002000-1b8f0016e912/go.mod h1:no/Y67Jkk/9WuGR0JG/JseM9irFbnEPbuWV2EELPNuM=
github.com/jackc/pgx/v4 v4.0.0-pre1.0.20190824185557-6972a5742186/go.mod h1:X+GQnOEnf1dqHGpw7JmHqHc1NxDoalibchSk9/RWuDc=
github.com/jackc/pgx/v4 v4.12.1-0.20210724153913-640aa07df17c/go.mod h1:1QD0+tgSXP7iUjYm9C1NxKhny7lq6ee99u/z+IHFcgs=
github.com/jackc/pgx/v4 v4.18.3 h1:dE2/TrEsGX3RBprb3qryqSV9Y60iZN1C6i8IrmW9/BA=
github.com/jackc/pgx/v4 v4.18.3/go.mod h1:Ey4Oru5tH5sB6tV7hDmfWFahwF15Eb7DNXlRKx2CkVw=
github.com/jackc/puddle v0.0.0-20190413234325-e4ced69a3a2b/go.mod h1:m4B5Dj62Y0fbyuIc15OsIqK0+JU8nkqQjsgx7dvjSWk=
github.com/jackc/puddle v0.0.0-20190608224051-11cab39313c9/go.mod h1:m4B5Dj62Y0fbyuIc15OsIqK0+JU8nkqQjsgx7dvjSWk=
github.com/jackc/puddle v1.1.3/go.mod h1:m4B5Dj62Y0fbyuIc15OsIqK0+JU8nkqQjsgx7dvjSWk=
github.com/jackc/puddle v1.3.0 h1:eHK/5clGOatcjX3oWGBO/MpxpbHzSwud5EWTSCI+MX0=
github.com/jackc/puddle v1.3.0/go.mod h1:m4B5Dj62Y0fbyuIc15OsIqK0+JU8nkqQjsgx7dvjSWk=
github.com/joho/godotenv v1.5.1 h1:7eLL/+HRGLY0ldzfGMeQkb7vMd0as4CfYvUVzLqw0N0=
github.com/joho/godotenv v1.5.1/go.mod h1:f4LDr5Voq0i2e/R5DDNOoa2zzDfwtkZa6DnEwAbqwq4=
github.com/josharian/intern v1.0.0 h1:vlS4z54oSdjm0bgjRigI+G1HpF+tI+9rE5LLzOg8HmY=
github.com/josharian/intern v1.0.0/go.mod h1:5DoeVV0s6jJacbCEi61lwdGj/aVlrQvzHFFd8Hwg//Y=
github.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=
github.com/konsorten/go-windows-terminal-sequences v1.0.1/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=
github.com/konsorten/go-windows-terminal-sequences v1.0.2/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=
github.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=
github.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=
github.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=
github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
github.com/kr/pty v1.1.8/go.mod h1:O1sed60cT9XZ5uDucP5qwvh+TE3NnUj51EiZO/lmSfw=
github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=
github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
github.com/leodido/go-urn v1.4.0 h1:WT9HwE9SGECu3lg4d/dIA+jxlljEa1/ffXKmRjqdmIQ=
github.com/leodido/go-urn v1.4.0/go.mod h1:bvxc+MVxLKB4z00jd1z+Dvzr47oO32F/QSNjSBOlFxI=
github.com/lib/pq v1.0.0/go.mod h1:5WUZQaWbwv1U+lTReE5YruASi9Al49XbQIvNi/34Woo=
github.com/lib/pq v1.1.0/go.mod h1:5WUZQaWbwv1U+lTReE5YruASi9Al49XbQIvNi/34Woo=
github.com/lib/pq v1.2.0/go.mod h1:5WUZQaWbwv1U+lTReE5YruASi9Al49XbQIvNi/34Woo=
github.com/lib/pq v1.10.2/go.mod h1:AlVN5x4E4T544tWzH6hKfbfQvm3HdbOxrmggDNAPY9o=
github.com/lib/pq v1.10.9 h1:YXG7RB+JIjhP29X+OtkiDnYaXQwpS4JEWq7dtCCRUEw=
github.com/lib/pq v1.10.9/go.mod h1:AlVN5x4E4T544tWzH6hKfbfQvm3HdbOxrmggDNAPY9o=
github.com/mailru/easyjson v0.7.7 h1:UGYAvKxe3sBsEDzO8ZeWOSlIQfWFlxbzLZe7hwFURr0=
github.com/mailru/easyjson v0.7.7/go.mod h1:xzfreul335JAWq5oZzymOObrkdz5UnU4kGfJJLY9Nlc=
github.com/mattn/go-colorable v0.1.1/go.mod h1:FuOcm+DKB9mbwrcAfNl7/TZVBZ6rcnceauSikq3lYCQ=
github.com/mattn/go-colorable v0.1.6/go.mod h1:u6P/XSegPjTcexA+o6vUJrdnUu04hMope9wVRipJSqc=
github.com/mattn/go-isatty v0.0.5/go.mod h1:Iq45c/XA43vh69/j3iqttzPXn0bhXyGjM0Hdxcsrc5s=
github.com/mattn/go-isatty v0.0.7/go.mod h1:Iq45c/XA43vh69/j3iqttzPXn0bhXyGjM0Hdxcsrc5s=
github.com/mattn/go-isatty v0.0.12/go.mod h1:cbi8OIDigv2wuxKPP5vlRcQ1OAZbq2CE4Kysco4FUpU=
github.com/nxadm/tail v1.4.8 h1:nPr65rt6Y5JFSKQO7qToXr7pePgD6Gwiw05lkbyAQTE=
github.com/nxadm/tail v1.4.8/go.mod h1:+ncqLTQzXmGhMZNUePPaPqPvBxHAIsmXswZKocGu+AU=
github.com/onsi/ginkgo v1.16.5 h1:8xi0RTUf59SOSfEtZMvwTvXYMzG4gV23XVHOZiXNtnE=
github.com/onsi/ginkgo v1.16.5/go.mod h1:+E8gABHa3K6zRBolWtd+ROzc/U5bkGt0FwiG042wbpU=
github.com/onsi/gomega v1.18.1 h1:M1GfJqGRrBrrGGsbxzV5dqM2U2ApXefZCQpkukxYRLE=
github.com/onsi/gomega v1.18.1/go.mod h1:0q+aL8jAiMXy9hbwj2mr5GziHiwhAIQpFmmtT5hitRs=
github.com/pkg/errors v0.8.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=
github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/rogpeppe/go-internal v1.3.0/go.mod h1:M8bDsm7K2OlrFYOpmOWEs/qY81heoFRclV5y23lUDJ4=
github.com/rogpeppe/go-internal v1.11.0 h1:cWPaGQEPrBb5/AsnsZesgZZ9yb1OQ+GOISoDNXVBh4M=
github.com/rogpeppe/go-internal v1.11.0/go.mod h1:ddIwULY96R17DhadqLgMfk9H9tvdUzkipdSkR5nkCZA=
github.com/rs/xid v1.2.1/go.mod h1:+uKXf+4Djp6Md1KODXJxgGQPKngRmWyn10oCKFzNHOQ=
github.com/rs/zerolog v1.13.0/go.mod h1:YbFCdg8HfsridGWAh22vktObvhZbQsZXe4/zB0OKkWU=
github.com/rs/zerolog v1.15.0/go.mod h1:xYTKnLHcpfU2225ny5qZjxnj9NvkumZYjJHlAThCjNc=
github.com/satori/go.uuid v1.2.0/go.mod h1:dA0hQrYB0VpLJoorglMZABFdXlWrHn1NEOzdhQKdks0=
github.com/shopspring/decimal v0.0.0-20180709203117-cd690d0c9e24/go.mod h1:M+9NzErvs504Cn4c5DxATwIqPbtswREoFCre64PpcG4=
github.com/shopspring/decimal v1.2.0 h1:abSATXmQEYyShuxI4/vyW3tV1MrKAJzCZ/0zLUXYbsQ=
github.com/shopspring/decimal v1.2.0/go.mod h1:DKyhrW/HYNuLGql+MJL6WCR6knT2jwCFRcu2hWCYk4o=
github.com/sirupsen/logrus v1.4.1/go.mod h1:ni0Sbl8bgC9z8RoU9G6nDWqqs/fq4eDPysMBDgk/93Q=
github.com/sirupsen/logrus v1.4.2/go.mod h1:tLMulIdttU9McNUspp0xgXVQah82FyeX6MwdIuYE2rE=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.1.1/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.2.0/go.mod h1:qt09Ya8vawLte6SNmTgCsAVtYtaKzEcn8ATUoHMkEqE=
github.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=
github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=
github.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=
github.com/stretchr/testify v1.5.1/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=
github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=
github.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
github.com/swaggo/files v1.0.1 h1:J1bVJ4XHZNq0I46UU90611i9/YzdrF7x92oX1ig5IdE=
github.com/swaggo/files v1.0.1/go.mod h1:0qXmMNH6sXNf+73t65aKeB+ApmgxdnkQzVTAj2uaMUg=
github.com/swaggo/http-swagger v1.3.4 h1:q7t/XLx0n15H1Q9/tk3Y9L4n210XzJF5WtnDX64a5ww=
github.com/swaggo/http-swagger v1.3.4/go.mod h1:9dAh0unqMBAlbp1uE2Uc2mQTxNMU/ha4UbucIg1MFkQ=
github.com/swaggo/swag v1.16.3 h1:PnCYjPCah8FK4I26l2F/KQ4yz3sILcVUN3cTlBFA9Pg=
github.com/swaggo/swag v1.16.3/go.mod h1:DImHIuOFXKpMFAQjcC7FG4m3Dg4+QuUgUzJmKjI/gRk=
github.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=
github.com/zenazn/goji v0.9.0/go.mod h1:7S9M489iMyHBNxwZnk9/EHS098H4/F6TATF2mIxtB1Q=
go.uber.org/atomic v1.3.2/go.mod h1:gD2HeocX3+yG+ygLZcrzQJaqmWj9AIm7n08wl/qW/PE=
go.uber.org/atomic v1.4.0/go.mod h1:gD2HeocX3+yG+ygLZcrzQJaqmWj9AIm7n08wl/qW/PE=
go.uber.org/atomic v1.5.0/go.mod h1:sABNBOSYdrvTF6hTgEIbc7YasKWGhgEQZyfxyTvoXHQ=
go.uber.org/atomic v1.6.0/go.mod h1:sABNBOSYdrvTF6hTgEIbc7YasKWGhgEQZyfxyTvoXHQ=
go.uber.org/multierr v1.1.0/go.mod h1:wR5kodmAFQ0UK8QlbwjlSNy0Z68gJhDJUG5sjR94q/0=
go.uber.org/multierr v1.3.0/go.mod h1:VgVr7evmIr6uPjLBxg28wmKNXyqE9akIJ5XnfpiKl+4=
go.uber.org/multierr v1.5.0/go.mod h1:FeouvMocqHpRaaGuG9EjoKcStLC43Zu/fmqdUMPcKYU=
go.uber.org/tools v0.0.0-20190618225709-2cfd321de3ee/go.mod h1:vJERXedbb3MVM5f9Ejo0C68/HhF8uaILCdgjnY+goOA=
go.uber.org/zap v1.9.1/go.mod h1:vwi/ZaCAaUcBkycHslxD9B2zi4UTXhF60s6SWpuDF0Q=
go.uber.org/zap v1.10.0/go.mod h1:vwi/ZaCAaUcBkycHslxD9B2zi4UTXhF60s6SWpuDF0Q=
go.uber.org/zap v1.13.0/go.mod h1:zwrFLgMcdUuIBviXEYEH1YKNaOBnKXsx2IPda5bBwHM=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20190411191339-88737f569e3a/go.mod h1:WFFai1msRO1wXaEeE5yQxYXgSfI8pQAWXbQop6sCtWE=
golang.org/x/crypto v0.0.0-20190510104115-cbcb75029529/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
golang.org/x/crypto v0.0.0-20190820162420-60c769a6c586/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
golang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
golang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
golang.org/x/crypto v0.0.0-20201203163018-be400aefbc4c/go.mod h1:jdWPYTVW3xRLrWPugEBEK3UY2ZEsg3UU495nc5E+M+I=
golang.org/x/crypto v0.0.0-20210616213533-5ff15b29337e/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=
golang.org/x/crypto v0.0.0-20210711020723-a769d52b0f97/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=
golang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=
golang.org/x/crypto v0.25.0 h1:ypSNr+bnYL2YhwoMt2zPxHFmbAN1KZs/njMG3hxUp30=
golang.org/x/crypto v0.25.0/go.mod h1:T+wALwcMOSE0kXgUAnPAHqTLW+XHgcELELW8VaDgm/M=
golang.org/x/lint v0.0.0-20190930215403-16217165b5de/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
golang.org/x/mod v0.0.0-20190513183733-4bf6d317e70e/go.mod h1:mXi4GBBbnImb6dmsKGUJ2LatrhH/nqhxcFungHvyanc=
golang.org/x/mod v0.1.1-0.20191105210325-c90efee705ee/go.mod h1:QqPTAvyqsEbceGzBzNggFXnrqF1CaUcvgkdR5Ot7KZg=
golang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=
golang.org/x/mod v0.19.0 h1:fEdghXQSo20giMthA7cd28ZC+jts4amQ3YMXiP5oMQ8=
golang.org/x/mod v0.19.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=
golang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20190813141303-74dc4d7220e7/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=
golang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=
golang.org/x/net v0.7.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=
golang.org/x/net v0.27.0 h1:5K3Njcw06/l2y9vpGCSdcxWOYHOUk3dVNGDXN+FvAys=
golang.org/x/net v0.27.0/go.mod h1:dDi0PyhWNoiUOrAS8uXv/vnScO4wnHQO4mj9fn/RytE=
golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.7.0 h1:YsImfSBoP9QPYL0xyKJPq0gcaJdG3rInoqxTWbfQu9M=
golang.org/x/sync v0.7.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
golang.org/x/sys v0.0.0-20180905080454-ebe1bf3edb33/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190222072716-a9d3bda3a223/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190403152447-81d4e9dc473e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190422165155-953cdadca894/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190813064441-fde4db37ae7a/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20191026070338-33540a1f6037/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200116001909-b77594299b42/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200223170610-d5e6a3e2c0ae/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.22.0 h1:RI27ohtqKCnwULzJLqkv897zojh5/DwS/ENaMzUOaWI=
golang.org/x/sys v0.22.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/term v0.0.0-20201117132131-f5c789dd3221/go.mod h1:Nr5EML6q2oocZ2LXRh80K7BxOlk5/8JxuGnuhpl+muw=
golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
golang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=
golang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=
golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.4/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=
golang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=
golang.org/x/text v0.16.0 h1:a94ExnEXNtEwYLGJSIUxnWoxoRz/ZcCsV63ROupILh4=
golang.org/x/text v0.16.0/go.mod h1:GhwF1Be+LQoKShO3cGOHzqOgRrGaYc9AvblQOmPVHnI=
golang.org/x/time v0.5.0 h1:o7cqy6amK/52YcAKIPlM3a+Fpj35zvRj2TP+e1xFSfk=
golang.org/x/time v0.5.0/go.mod h1:3BpzKBy/shNhVucY/MWOyx10tF3SFh9QdLuxbVysPQM=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
golang.org/x/tools v0.0.0-20190425163242-31fd60d6bfdc/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=
golang.org/x/tools v0.0.0-20190621195816-6e04913cbbac/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=
golang.org/x/tools v0.0.0-20190823170909-c4a336ef6a2f/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20191029041327-9cc4af7d6b2c/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20191029190741-b9c20aec41a5/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20200103221440-774c71fcf114/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
golang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=
golang.org/x/tools v0.23.0 h1:SGsXPZ+2l4JsgaCKkx+FQ9YZ5XEtA1GZYuoDjenLjvg=
golang.org/x/tools v0.23.0/go.mod h1:pnu6ufv6vQkll6szChhK3C3L/ruaIv5eBeztNG8wtsI=
golang.org/x/xerrors v0.0.0-20190410155217-1f06c39b4373/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20190513163551-3ee3066db522/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=
gopkg.in/errgo.v2 v2.1.0/go.mod h1:hNsd1EY+bozCKY1Ytp96fpM3vjJbqLJn88ws8XvfDNI=
gopkg.in/inconshreveable/log15.v2 v2.0.0-20180818164646-67afb5ed74ec/go.mod h1:aPpfJ7XW+gOuirDoZ8gHhLh3kZ1B08FtV2bbmy7Jv3s=
gopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7 h1:uRGJdciOHaEIrze2W8Q3AKkepLTh2hOroT7a+7czfdQ=
gopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7/go.mod h1:dt/ZhP58zS4L8KSrWDmTeBkI65Dw0HsyUHuEVlX15mw=
gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.4.0 h1:D8xgwECY7CYvx+Y2n4sBz93Jn9JRvxdiyyo8CTfuKaY=
gopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
honnef.co/go/tools v0.0.1-2019.2.3/go.mod h1:a3bituU0lyd329TUQxRnasdCoJDkEUEAqEt0JzvZhAg=

--- End of backend/go.sum ---

--- Start of backend/README.md ---

--- End of backend/README.md ---

--- Start of backend/cmd/server/main.go ---
package main

import (
	"fmt"
	"log"
	"net/http"

	"github.com/gorilla/handlers"
	"github.com/gorilla/mux"
	v1 "github.com/mcopur/sap-assist/internal/api/v1"
	"github.com/mcopur/sap-assist/internal/config"
	"github.com/mcopur/sap-assist/internal/database"
	"github.com/mcopur/sap-assist/internal/middleware"
	"github.com/mcopur/sap-assist/internal/service"
	httpSwagger "github.com/swaggo/http-swagger"
	"golang.org/x/time/rate"
)

// @title SAP Assist API
// @version 1.0
// @description This is a sample server for SAP Assist application.
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io

// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html

// @host localhost:8080
// @BasePath /api/v1

func main() {
	cfg, err := config.LoadConfig()
	if err != nil {
		log.Fatalf("Failed to load config: %v", err)
	}

	db, err := database.InitDB(cfg)
	if err != nil {
		log.Fatalf("Failed to initialize database: %v", err)
	}
	defer db.Close()

	repo := database.NewRepository(db)
	nlpService := service.NewNLPService(cfg.NLPServiceURL)
	sapConfig := &service.SAPConfig{
		BaseURL:      cfg.SAPBaseURL,
		ClientID:     cfg.SAPClientID,
		ClientSecret: cfg.SAPClientSecret,
	}
	svc := service.NewService(repo, nlpService, sapConfig)

	limiter := middleware.NewIPRateLimiter(rate.Limit(5), 10)

	corsOptions := handlers.CORS(
		handlers.AllowedOrigins([]string{cfg.AllowedOrigin}),
		handlers.AllowedMethods([]string{"GET", "POST", "PUT", "DELETE", "OPTIONS"}),
		handlers.AllowedHeaders([]string{"Content-Type", "Authorization"}),
		handlers.AllowCredentials(),
	)

	r := mux.NewRouter()

	r.Use(middleware.Logging)
	r.Use(corsOptions)
	r.Use(middleware.RateLimit(limiter))

	r.Methods("OPTIONS").HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
	})

	r.PathPrefix("/swagger/").Handler(httpSwagger.WrapHandler)

	apiV1 := v1.NewAPIv1(svc)
	apiV1Router := r.PathPrefix("/api/v1").Subrouter()
	apiV1.RegisterRoutes(apiV1Router)

	log.Printf("Starting server on :%d", cfg.ServerPort)
	log.Fatal(http.ListenAndServe(fmt.Sprintf(":%d", cfg.ServerPort), handlers.CompressHandler(r)))
}

--- End of backend/cmd/server/main.go ---

--- Start of backend/internal/middleware/ratelimit.go ---
package middleware

import (
	"context"
	"fmt"
	"net/http"
	"time"

	"github.com/go-redis/redis/v8"
	"github.com/mcopur/sap-assist/internal/utils"
)

type RedisRateLimiter struct {
	client      *redis.Client
	maxRequests int
	duration    time.Duration
}

func NewRedisRateLimiter(client *redis.Client, maxRequests int, duration time.Duration) *RedisRateLimiter {
	return &RedisRateLimiter{
		client:      client,
		maxRequests: maxRequests,
		duration:    duration,
	}
}

func (r *RedisRateLimiter) Allow(key string) bool {
	ctx := context.Background()
	now := time.Now().UnixNano()

	pipe := r.client.Pipeline()
	pipe.ZRemRangeByScore(ctx, key, "0", fmt.Sprintf("%d", now-(r.duration.Nanoseconds())))
	pipe.ZAdd(ctx, key, &redis.Z{Score: float64(now), Member: now})
	pipe.ZCard(ctx, key)
	pipe.Expire(ctx, key, r.duration)

	cmders, err := pipe.Exec(ctx)
	if err != nil {
		return false
	}

	reqCount := cmders[2].(*redis.IntCmd).Val()
	return reqCount <= int64(r.maxRequests)
}

func RateLimit(limiter *RedisRateLimiter) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if !limiter.Allow(r.RemoteAddr) {
				utils.RespondWithError(w, http.StatusTooManyRequests, "Rate limit exceeded")
				return
			}
			next.ServeHTTP(w, r)
		})
	}
}

--- End of backend/internal/middleware/ratelimit.go ---

--- Start of backend/internal/middleware/middleware.go ---
// backend/internal/middleware/middleware.go
package middleware

import (
	"log"
	"net/http"
	"time"

	"github.com/mcopur/sap-assist/internal/utils"
)

func Logging(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()
		log.Printf("Started %s %s", r.Method, r.URL.Path)
		next.ServeHTTP(w, r)
		log.Printf("Completed %s %s in %v", r.Method, r.URL.Path, time.Since(start))
	})
}

func BasicAuth(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		username, password, ok := r.BasicAuth()
		if !ok || username != "admin" || password != "password" {
			utils.RespondWithError(w, http.StatusUnauthorized, "Unauthorized")
			return
		}
		next.ServeHTTP(w, r)
	})
}

--- End of backend/internal/middleware/middleware.go ---

--- Start of backend/internal/database/database.go ---
// backend/internal/database/database.go
package database

import (
	"context"
	"fmt"
	"time"

	"github.com/jackc/pgx/v4/pgxpool"
	"github.com/mcopur/sap-assist/internal/config"
	"github.com/mcopur/sap-assist/internal/repository"
)

var db *pgxpool.Pool

func InitDB(cfg *config.Config) (*pgxpool.Pool, error) {
	connectionString := fmt.Sprintf("postgresql://%s:%s@%s:%d/%s",
		cfg.DBUser, cfg.DBPassword, cfg.DBHost, cfg.DBPort, cfg.DBName)

	poolConfig, err := pgxpool.ParseConfig(connectionString)
	if err != nil {
		return nil, fmt.Errorf("unable to parse connection string: %v", err)
	}

	poolConfig.MaxConns = 10
	poolConfig.MinConns = 2
	poolConfig.MaxConnLifetime = time.Hour
	poolConfig.MaxConnIdleTime = 30 * time.Minute

	pool, err := pgxpool.ConnectConfig(context.Background(), poolConfig)
	if err != nil {
		return nil, fmt.Errorf("unable to connect to database: %v", err)
	}

	return pool, nil
}

func GetDB() *pgxpool.Pool {
	return db
}

func NewRepository(db *pgxpool.Pool) *repository.PostgresRepository {
	return repository.NewPostgresRepository(db)
}

--- End of backend/internal/database/database.go ---

--- Start of backend/internal/repository/postgres_repository.go ---
// backend/internal/repository/postgres_repository.go
package repository

import (
    "context"
    "fmt"

    "github.com/jackc/pgx/v4/pgxpool"
    "github.com/mcopur/sap-assist/internal/models"
    "github.com/mcopur/sap-assist/internal/utils"
)

type PostgresRepository struct {
    db *pgxpool.Pool
}

func NewPostgresRepository(db *pgxpool.Pool) *PostgresRepository {
    return &PostgresRepository{db: db}
}

// User Repository Methods

func (r *PostgresRepository) CreateUser(user *models.User) error {
    encryptedPassword, err := utils.Encrypt(user.PasswordHash)
    if err != nil {
        utils.ErrorLogger.Printf("Error encrypting password: %v", err)
        return fmt.Errorf("error encrypting password: %w", err)
    }

    query := `INSERT INTO users (username, email, password_hash, first_name, last_name, role) 
              VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, created_at, updated_at`
    
    err = r.db.QueryRow(context.Background(), query, 
        user.Username, user.Email, encryptedPassword, user.FirstName, user.LastName, user.Role).
        Scan(&user.ID, &user.CreatedAt, &user.UpdatedAt)
    
    if err != nil {
        utils.ErrorLogger.Printf("Error creating user: %v", err)
        return fmt.Errorf("error creating user: %w", err)
    }
    return nil
}

func (r *PostgresRepository) GetUserByID(id int) (*models.User, error) {
    query := `SELECT id, username, email, password_hash, first_name, last_name, role, created_at, updated_at 
              FROM users WHERE id = $1`
    
    user := &models.User{}
    err := r.db.QueryRow(context.Background(), query, id).Scan(
        &user.ID, &user.Username, &user.Email, &user.PasswordHash, &user.FirstName, 
        &user.LastName, &user.Role, &user.CreatedAt, &user.UpdatedAt,
    )
    
    if err != nil {
        utils.ErrorLogger.Printf("Error getting user by ID %d: %v", id, err)
        return nil, fmt.Errorf("error getting user: %w", err)
    }

    decryptedPassword, err := utils.Decrypt(user.PasswordHash)
    if err != nil {
        utils.ErrorLogger.Printf("Error decrypting password for user %d: %v", id, err)
        return nil, fmt.Errorf("error decrypting password: %w", err)
    }
    user.PasswordHash = decryptedPassword

    return user, nil
}

func (r *PostgresRepository) UpdateUser(user *models.User) error {
    encryptedPassword, err := utils.Encrypt(user.PasswordHash)
    if err != nil {
        utils.ErrorLogger.Printf("Error encrypting password: %v", err)
        return fmt.Errorf("error encrypting password: %w", err)
    }

    query := `UPDATE users SET username = $1, email = $2, password_hash = $3, first_name = $4, 
              last_name = $5, role = $6, updated_at = CURRENT_TIMESTAMP 
              WHERE id = $7 RETURNING updated_at`
    
    err = r.db.QueryRow(context.Background(), query, 
        user.Username, user.Email, encryptedPassword, user.FirstName, user.LastName, user.Role, user.ID).
        Scan(&user.UpdatedAt)
    
    if err != nil {
        utils.ErrorLogger.Printf("Error updating user %d: %v", user.ID, err)
        return fmt.Errorf("error updating user: %w", err)
    }
    return nil
}

func (r *PostgresRepository) DeleteUser(id int) error {
    query := `DELETE FROM users WHERE id = $1`
    
    _, err := r.db.Exec(context.Background(), query, id)
    if err != nil {
        utils.ErrorLogger.Printf("Error deleting user %d: %v", id, err)
        return fmt.Errorf("error deleting user: %w", err)
    }
    return nil
}

// Leave Request Repository Methods

func (r *PostgresRepository) CreateLeaveRequest(request *models.LeaveRequest) error {
    query := `INSERT INTO leave_requests (user_id, start_date, end_date, leave_type, status, reason) 
              VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, created_at, updated_at`
    
    err := r.db.QueryRow(context.Background(), query, 
        request.UserID, request.StartDate, request.EndDate, request.LeaveType, request.Status, request.Reason).
        Scan(&request.ID, &request.CreatedAt, &request.UpdatedAt)
    
    if err != nil {
        utils.ErrorLogger.Printf("Error creating leave request: %v", err)
        return fmt.Errorf("error creating leave request: %w", err)
    }
    return nil
}

func (r *PostgresRepository) GetLeaveRequestByID(id int) (*models.LeaveRequest, error) {
    query := `SELECT id, user_id, start_date, end_date, leave_type, status, reason, created_at, updated_at 
              FROM leave_requests WHERE id = $1`
    
    request := &models.LeaveRequest{}
    err := r.db.QueryRow(context.Background(), query, id).Scan(
        &request.ID, &request.UserID, &request.StartDate, &request.EndDate, &request.LeaveType, 
        &request.Status, &request.Reason, &request.CreatedAt, &request.UpdatedAt,
    )
    
    if err != nil {
        utils.ErrorLogger.Printf("Error getting leave request by ID %d: %v", id, err)
        return nil, fmt.Errorf("error getting leave request: %w", err)
    }
    return request, nil
}

func (r *PostgresRepository) GetLeaveRequestsByUserIDWithPagination(userID, offset, limit int) ([]*models.LeaveRequest, error) {
    query := `SELECT id, user_id, start_date, end_date, leave_type, status, reason, created_at, updated_at 
              FROM leave_requests 
              WHERE user_id = $1 
              ORDER BY created_at DESC 
              LIMIT $2 OFFSET $3`
    
    rows, err := r.db.Query(context.Background(), query, userID, limit, offset)
    if err != nil {
        utils.ErrorLogger.Printf("Error getting leave requests for user %d: %v", userID, err)
        return nil, fmt.Errorf("error getting leave requests: %w", err)
    }
    defer rows.Close()

    var requests []*models.LeaveRequest
    for rows.Next() {
        request := &models.LeaveRequest{}
        err := rows.Scan(
            &request.ID, &request.UserID, &request.StartDate, &request.EndDate, 
            &request.LeaveType, &request.Status, &request.Reason, 
            &request.CreatedAt, &request.UpdatedAt,
        )
        if err != nil {
            utils.ErrorLogger.Printf("Error scanning leave request: %v", err)
            return nil, fmt.Errorf("error scanning leave request: %w", err)
        }
        requests = append(requests, request)
    }

    if err = rows.Err(); err != nil {
        utils.ErrorLogger.Printf("Error iterating leave requests: %v", err)
        return nil, fmt.Errorf("error iterating leave requests: %w", err)
    }

    return requests, nil
}

func (r *PostgresRepository) UpdateLeaveRequest(request *models.LeaveRequest) error {
    query := `UPDATE leave_requests SET start_date = $1, end_date = $2, leave_type = $3, 
              status = $4, reason = $5, updated_at = CURRENT_TIMESTAMP 
              WHERE id = $6 RETURNING updated_at`
    
    err := r.db.QueryRow(context.Background(), query, 
        request.StartDate, request.EndDate, request.LeaveType, request.Status, request.Reason, request.ID).
        Scan(&request.UpdatedAt)
    
    if err != nil {
        utils.ErrorLogger.Printf("Error updating leave request %d: %v", request.ID, err)
        return fmt.Errorf("error updating leave request: %w", err)
    }
    return nil
}

func (r *PostgresRepository) DeleteLeaveRequest(id int) error {
    query := `DELETE FROM leave_requests WHERE id = $1`
    
    _, err := r.db.Exec(context.Background(), query, id)
    if err != nil {
        utils.ErrorLogger.Printf("Error deleting leave request %d: %v", id, err)
        return fmt.Errorf("error deleting leave request: %w", err)
    }
    return nil
}

// Purchase Request Repository Methods

func (r *PostgresRepository) CreatePurchaseRequest(request *models.PurchaseRequest) error {
    query := `INSERT INTO purchase_requests (user_id, item_name, quantity, estimated_cost, status, reason) 
              VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, created_at, updated_at`
    
    err := r.db.QueryRow(context.Background(), query, 
        request.UserID, request.ItemName, request.Quantity, request.EstimatedCost, request.Status, request.Reason).
        Scan(&request.ID, &request.CreatedAt, &request.UpdatedAt)
    
    if err != nil {
        utils.ErrorLogger.Printf("Error creating purchase request: %v", err)
        return fmt.Errorf("error creating purchase request: %w", err)
    }
    return nil
}

func (r *PostgresRepository) GetPurchaseRequestByID(id int) (*models.PurchaseRequest, error) {
    query := `SELECT id, user_id, item_name, quantity, estimated_cost, status, reason, created_at, updated_at 
              FROM purchase_requests WHERE id = $1`
    
    request := &models.PurchaseRequest{}
    err := r.db.QueryRow(context.Background(), query, id).Scan(
        &request.ID, &request.UserID, &request.ItemName, &request.Quantity, &request.EstimatedCost,
        &request.Status, &request.Reason, &request.CreatedAt, &request.UpdatedAt,
    )
    
    if err != nil {
        utils.ErrorLogger.Printf("Error getting purchase request by ID %d: %v", id, err)
        return nil, fmt.Errorf("error getting purchase request: %w", err)
    }
    return request, nil
}

func (r *PostgresRepository) GetPurchaseRequestsByUserIDWithPagination(userID, offset, limit int) ([]*models.PurchaseRequest, error) {
    query := `SELECT id, user_id, item_name, quantity, estimated_cost, status, reason, created_at, updated_at 
              FROM purchase_requests 
              WHERE user_id = $1 
              ORDER BY created_at DESC 
              LIMIT $2 OFFSET $3`
    
    rows, err := r.db.Query(context.Background(), query, userID, limit, offset)
    if err != nil {
        utils.ErrorLogger.Printf("Error getting purchase requests for user %d: %v", userID, err)
        return nil, fmt.Errorf("error getting purchase requests: %w", err)
    }
    defer rows.Close()

    var requests []*models.PurchaseRequest
    for rows.Next() {
        request := &models.PurchaseRequest{}
        err := rows.Scan(
            &request.ID, &request.UserID, &request.ItemName, &request.Quantity, 
            &request.EstimatedCost, &request.Status, &request.Reason, 
            &request.CreatedAt, &request.UpdatedAt,
        )
        if err != nil {
            utils.ErrorLogger.Printf("Error scanning purchase request: %v", err)
            return nil, fmt.Errorf("error scanning purchase request: %w", err)
        }
        requests = append(requests, request)
    }

    if err = rows.Err(); err != nil {
        utils.ErrorLogger.Printf("Error iterating purchase requests: %v", err)
        return nil, fmt.Errorf("error iterating purchase requests: %w", err)
    }

    return requests, nil
}

func (r *PostgresRepository) UpdatePurchaseRequest(request *models.PurchaseRequest) error {
    query := `UPDATE purchase_requests SET item_name = $1, quantity = $2, estimated_cost = $3, 
              status = $4, reason = $5, updated_at = CURRENT_TIMESTAMP 
              WHERE id = $6 RETURNING updated_at`
    
    err := r.db.QueryRow(context.Background(), query, 
        request.ItemName, request.Quantity, request.EstimatedCost, request.Status, request.Reason, request.ID).
        Scan(&request.UpdatedAt)
    
    if err != nil {
        utils.ErrorLogger.Printf("Error updating purchase request %d: %v", request.ID, err)
        return fmt.Errorf("error updating purchase request: %w", err)
    }
    return nil
}

func (r *PostgresRepository) DeletePurchaseRequest(id int) error {
    query := `DELETE FROM purchase_requests WHERE id = $1`
    
    _, err := r.db.Exec(context.Background(), query, id)
    if err != nil {
        utils.ErrorLogger.Printf("Error deleting purchase request %d: %v", id, err)
        return fmt.Errorf("error deleting purchase request: %w", err)
    }
    return nil
}
--- End of backend/internal/repository/postgres_repository.go ---

--- Start of backend/internal/repository/repository.go ---
// backend/internal/repository/repository.go
package repository

import "github.com/mcopur/sap-assist/internal/models"

type UserRepository interface {
    Create(user *models.User) error
    GetByID(id int) (*models.User, error)
    Update(user *models.User) error
    Delete(id int) error
}

type LeaveRequestRepository interface {
    Create(request *models.LeaveRequest) error
    GetByID(id int) (*models.LeaveRequest, error)
    GetByUserID(userID int) ([]*models.LeaveRequest, error)
    Update(request *models.LeaveRequest) error
    Delete(id int) error
}

type PurchaseRequestRepository interface {
    Create(request *models.PurchaseRequest) error
    GetByID(id int) (*models.PurchaseRequest, error)
    GetByUserID(userID int) ([]*models.PurchaseRequest, error)
    Update(request *models.PurchaseRequest) error
    Delete(id int) error
}
--- End of backend/internal/repository/repository.go ---

--- Start of backend/internal/config/config.go ---
// backend/internal/config/config.go
package config

import (
	"fmt"
	"os"
	"strconv"

	"github.com/joho/godotenv"
)

type Config struct {
	DBHost          string
	DBPort          int
	DBUser          string
	DBPassword      string
	DBName          string
	ServerPort      int
	NLPServiceURL   string
	SAPBaseURL      string
	SAPClientID     string
	SAPClientSecret string
	AllowedOrigin   string
	RedisAddr       string
}

func LoadConfig() (*Config, error) {
	err := godotenv.Load()
	if err != nil {
		return nil, fmt.Errorf("error loading .env file: %w", err)
	}

	config := &Config{
		DBHost:          getEnv("DB_HOST", "localhost"),
		DBPort:          getEnvAsInt("DB_PORT", 5432),
		DBUser:          getEnv("DB_USER", ""),
		DBPassword:      getEnv("DB_PASSWORD", ""),
		DBName:          getEnv("DB_NAME", ""),
		ServerPort:      getEnvAsInt("SERVER_PORT", 8080),
		NLPServiceURL:   getEnv("NLP_SERVICE_URL", "http://localhost:5000"),
		SAPBaseURL:      getEnv("SAP_BASE_URL", ""),
		SAPClientID:     getEnv("SAP_CLIENT_ID", ""),
		SAPClientSecret: getEnv("SAP_CLIENT_SECRET", ""),
		AllowedOrigin:   getEnv("ALLOWED_ORIGIN", "http://localhost:5173"),
		RedisAddr:       getEnv("REDIS_ADDR", "localhost:6379"),
	}

	return config, nil
}

func getEnv(key, defaultValue string) string {
	value := os.Getenv(key)
	if value == "" {
		return defaultValue
	}
	return value
}

func getEnvAsInt(key string, defaultValue int) int {
	valueStr := getEnv(key, "")
	if value, err := strconv.Atoi(valueStr); err == nil {
		return value
	}
	return defaultValue
}

--- End of backend/internal/config/config.go ---

--- Start of backend/internal/utils/logger.go ---
// backend/internal/utils/errors.go
package utils

import (
    "log"
    "os"
)

var (
    InfoLogger  *log.Logger
    ErrorLogger *log.Logger
)

func init() {
    InfoLogger = log.New(os.Stdout, "INFO: ", log.Ldate|log.Ltime|log.Lshortfile)
    ErrorLogger = log.New(os.Stderr, "ERROR: ", log.Ldate|log.Ltime|log.Lshortfile)
}
--- End of backend/internal/utils/logger.go ---

--- Start of backend/internal/utils/response.go ---
package utils

import (
	"encoding/json"
	"net/http"
)

func RespondWithError(w http.ResponseWriter, code int, message string) {
	RespondWithJSON(w, code, map[string]string{"error": message})
}

func RespondWithJSON(w http.ResponseWriter, code int, payload interface{}) {
	response, _ := json.Marshal(payload)
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	w.Write(response)
}

--- End of backend/internal/utils/response.go ---

--- Start of backend/internal/utils/crypto.go ---
// backend/internal/utils/crypto.go
package utils

import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/rand"
    "encoding/base64"
    "errors"
    "io"
)

var secretKey = []byte("your-32-byte-secret-key-here")

func Encrypt(plaintext string) (string, error) {
    block, err := aes.NewCipher(secretKey)
    if err != nil {
        return "", err
    }

    ciphertext := make([]byte, aes.BlockSize+len(plaintext))
    iv := ciphertext[:aes.BlockSize]
    if _, err := io.ReadFull(rand.Reader, iv); err != nil {
        return "", err
    }

    stream := cipher.NewCFBEncrypter(block, iv)
    stream.XORKeyStream(ciphertext[aes.BlockSize:], []byte(plaintext))

    return base64.URLEncoding.EncodeToString(ciphertext), nil
}

func Decrypt(cryptoText string) (string, error) {
    ciphertext, err := base64.URLEncoding.DecodeString(cryptoText)
    if err != nil {
        return "", err
    }

    block, err := aes.NewCipher(secretKey)
    if err != nil {
        return "", err
    }

    if len(ciphertext) < aes.BlockSize {
        return "", errors.New("ciphertext too short")
    }
    iv := ciphertext[:aes.BlockSize]
    ciphertext = ciphertext[aes.BlockSize:]

    stream := cipher.NewCFBDecrypter(block, iv)
    stream.XORKeyStream(ciphertext, ciphertext)

    return string(ciphertext), nil
}
--- End of backend/internal/utils/crypto.go ---

--- Start of backend/internal/utils/errors.go ---
package utils

type AppError struct {
	Code    int    `json:"code"`
	Message string `json:"message"`
	Err     error  `json:"-"`
}

func (e *AppError) Error() string {
	return e.Message
}

func NewAppError(code int, message string, err error) *AppError {
	return &AppError{
		Code:    code,
		Message: message,
		Err:     err,
	}
}

--- End of backend/internal/utils/errors.go ---

--- Start of backend/internal/models/user.go ---
// backend/internal/models/user.go
package models

import "time"

type User struct {
    ID           int       `json:"id"`
    Username     string    `json:"username" validate:"required,min=3,max=50"`
    Email        string    `json:"email" validate:"required,email"`
    PasswordHash string    `json:"-" validate:"required"`
    FirstName    string    `json:"first_name" validate:"required"`
    LastName     string    `json:"last_name" validate:"required"`
    Role         string    `json:"role" validate:"required,oneof=admin user"`
    CreatedAt    time.Time `json:"created_at"`
    UpdatedAt    time.Time `json:"updated_at"`
}
--- End of backend/internal/models/user.go ---

--- Start of backend/internal/models/user_input.go ---
// backend/internal/models/user_input.go
package models

type UserInput struct {
	Text            string            `json:"text"`
	PersonnelNumber string            `json:"personnel_number"`
	Context         map[string]string `json:"context"`
}

--- End of backend/internal/models/user_input.go ---

--- Start of backend/internal/models/purchase_request.go ---
// backend/internal/models/purchase_request.go
package models

import "time"

type PurchaseRequest struct {
    ID             int       `json:"id"`
    UserID         int       `json:"user_id"`
    ItemName       string    `json:"item_name"`
    Quantity       int       `json:"quantity"`
    EstimatedCost  float64   `json:"estimated_cost"`
    Status         string    `json:"status"`
    Reason         string    `json:"reason"`
    CreatedAt      time.Time `json:"created_at"`
    UpdatedAt      time.Time `json:"updated_at"`
}
--- End of backend/internal/models/purchase_request.go ---

--- Start of backend/internal/models/intent_response.go ---
// backend/internal/models/intent_response.go
package models

type IntentResponse struct {
	Intent     string              `json:"intent"`
	Confidence float64             `json:"confidence"`
	Response   string              `json:"response"`
	Entities   map[string][]string `json:"entities"`
}

--- End of backend/internal/models/intent_response.go ---

--- Start of backend/internal/models/validation.go ---
// backend/internal/models/validation.go
package models

import (
    "github.com/go-playground/validator/v10"
)

var validate *validator.Validate

func init() {
    validate = validator.New()
}

func (u *User) Validate() error {
    return validate.Struct(u)
}

func (l *LeaveRequest) Validate() error {
    return validate.Struct(l)
}

func (p *PurchaseRequest) Validate() error {
    return validate.Struct(p)
}
--- End of backend/internal/models/validation.go ---

--- Start of backend/internal/models/leave_request.go ---
// backend/internal/models/leave_request.go
package models

import "time"

type LeaveRequest struct {
    ID        int       `json:"id"`
    UserID    int       `json:"user_id"`
    StartDate time.Time `json:"start_date"`
    EndDate   time.Time `json:"end_date"`
    LeaveType string    `json:"leave_type"`
    Status    string    `json:"status"`
    Reason    string    `json:"reason"`
    CreatedAt time.Time `json:"created_at"`
    UpdatedAt time.Time `json:"updated_at"`
}
--- End of backend/internal/models/leave_request.go ---

--- Start of backend/internal/models/pagination.go ---
// backend/internal/models/pagination.go
package models

type PaginationQuery struct {
    Page  int `form:"page" binding:"min=1"`
    Limit int `form:"limit" binding:"min=1,max=100"`
}

func (p *PaginationQuery) GetOffset() int {
    return (p.GetPage() - 1) * p.GetLimit()
}

func (p *PaginationQuery) GetLimit() int {
    if p.Limit == 0 {
        p.Limit = 10
    }
    return p.Limit
}

func (p *PaginationQuery) GetPage() int {
    if p.Page == 0 {
        p.Page = 1
    }
    return p.Page
}
--- End of backend/internal/models/pagination.go ---

--- Start of backend/internal/api/v1/handlers.go ---
package v1

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strconv"

	"github.com/gorilla/mux"
	"github.com/mcopur/sap-assist/internal/models"
	"github.com/mcopur/sap-assist/internal/service"
	"github.com/mcopur/sap-assist/internal/utils"
)

type APIv1 struct {
	service *service.Service
}

func NewAPIv1(service *service.Service) *APIv1 {
	return &APIv1{service: service}
}

func (api *APIv1) RegisterRoutes(r *mux.Router) {
	r.HandleFunc("/login", api.loginHandler).Methods("POST")
	r.HandleFunc("/users", api.createUserHandler).Methods("POST")
	r.HandleFunc("/users/{id}", api.getUserHandler).Methods("GET")
	r.HandleFunc("/users/{id}", api.updateUserHandler).Methods("PUT")
	r.HandleFunc("/users/{id}", api.deleteUserHandler).Methods("DELETE")
	r.HandleFunc("/leave-requests", api.createLeaveRequestHandler).Methods("POST")
	r.HandleFunc("/leave-requests/{id}", api.getLeaveRequestHandler).Methods("GET")
	r.HandleFunc("/leave-requests/{id}", api.updateLeaveRequestHandler).Methods("PUT")
	r.HandleFunc("/leave-requests/{id}", api.deleteLeaveRequestHandler).Methods("DELETE")
	r.HandleFunc("/users/{userId}/leave-requests", api.getLeaveRequestsByUserHandler).Methods("GET")
	r.HandleFunc("/purchase-requests", api.createPurchaseRequestHandler).Methods("POST")
	r.HandleFunc("/purchase-requests/{id}", api.getPurchaseRequestHandler).Methods("GET")
	r.HandleFunc("/purchase-requests/{id}", api.updatePurchaseRequestHandler).Methods("PUT")
	r.HandleFunc("/purchase-requests/{id}", api.deletePurchaseRequestHandler).Methods("DELETE")
	r.HandleFunc("/users/{userId}/purchase-requests", api.getPurchaseRequestsByUserHandler).Methods("GET")
	r.HandleFunc("/process", api.ProcessMessageHandler).Methods("POST")
}

func (api *APIv1) ProcessMessageHandler(w http.ResponseWriter, r *http.Request) {
	var userInput models.UserInput
	if err := json.NewDecoder(r.Body).Decode(&userInput); err != nil {
		utils.RespondWithError(w, http.StatusBadRequest, "Invalid request payload")
		return
	}

	intentResponse, err := api.service.ProcessMessage(userInput)
	if err != nil {
		log.Printf("Error processing message: %v", err)
		utils.RespondWithError(w, http.StatusInternalServerError, "Error processing message")
		return
	}

	if intentResponse.Intent == "confirm_annual_leave" || intentResponse.Intent == "confirm_excuse_leave" {
		dates := intentResponse.Entities["DATE"]
		if len(dates) >= 2 {
			leaveRequest, err := api.service.SendLeaveRequest(userInput.PersonnelNumber, dates[0], dates[1])
			if err != nil {
				log.Printf("Error sending leave request: %v", err)
				intentResponse.Response = fmt.Sprintf("İzin talebi oluşturulurken bir hata oluştu: %v", err)
			} else {
				intentResponse.Response = fmt.Sprintf("İzin Talebi Başarılı: %v", leaveRequest)
			}
		}
	}

	utils.RespondWithJSON(w, http.StatusOK, intentResponse)
}

func (api *APIv1) loginHandler(w http.ResponseWriter, r *http.Request) {
	var loginRequest struct {
		PersonnelNumber string `json:"personnel_number"`
		Password        string `json:"password"`
	}

	if err := json.NewDecoder(r.Body).Decode(&loginRequest); err != nil {
		utils.RespondWithError(w, http.StatusBadRequest, "Invalid request payload")
		return
	}

	token, err := api.service.Login(loginRequest.PersonnelNumber, loginRequest.Password)
	if err != nil {
		utils.RespondWithError(w, http.StatusUnauthorized, "Invalid credentials")
		return
	}

	utils.RespondWithJSON(w, http.StatusOK, map[string]string{"token": token})
}

// @Summary Create a new user
// @Description Create a new user with the input payload
// @Tags users
// @Accept  json
// @Produce  json
// @Param user body models.User true "Create user"
// @Success 201 {object} models.User
// @Failure 400 {object} utils.ErrorResponse
// @Failure 500 {object} utils.ErrorResponse
// @Router /users [post]
func (api *APIv1) createUserHandler(w http.ResponseWriter, r *http.Request) {
	var user models.User
	if err := json.NewDecoder(r.Body).Decode(&user); err != nil {
		utils.RespondWithError(w, http.StatusBadRequest, "Invalid request payload")
		return
	}
	if err := api.service.CreateUser(&user); err != nil {
		utils.RespondWithError(w, http.StatusInternalServerError, "Failed to create user")
		return
	}
	utils.RespondWithJSON(w, http.StatusCreated, user)
}

// @Summary Get a user by ID
// @Description Get a user by their ID
// @Tags users
// @Accept  json
// @Produce  json
// @Param id path int true "User ID"
// @Success 200 {object} models.User
// @Failure 400 {object} utils.ErrorResponse
// @Failure 404 {object} utils.ErrorResponse
// @Router /users/{id} [get]
func (api *APIv1) getUserHandler(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id, err := strconv.Atoi(vars["id"])
	if err != nil {
		utils.RespondWithError(w, http.StatusBadRequest, "Invalid user ID")
		return
	}
	user, err := api.service.GetUserByID(id)
	if err != nil {
		utils.RespondWithError(w, http.StatusNotFound, "User not found")
		return
	}
	utils.RespondWithJSON(w, http.StatusOK, user)
}

// @Summary Update a user
// @Description Update a user with the input payload
// @Tags users
// @Accept  json
// @Produce  json
// @Param id path int true "User ID"
// @Param user body models.User true "Update user"
// @Success 200 {object} models.User
// @Failure 400 {object} utils.ErrorResponse
// @Failure 500 {object} utils.ErrorResponse
// @Router /users/{id} [put]
func (api *APIv1) updateUserHandler(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id, err := strconv.Atoi(vars["id"])
	if err != nil {
		utils.RespondWithError(w, http.StatusBadRequest, "Invalid user ID")
		return
	}
	var user models.User
	if err := json.NewDecoder(r.Body).Decode(&user); err != nil {
		utils.RespondWithError(w, http.StatusBadRequest, "Invalid request payload")
		return
	}
	user.ID = id
	if err := api.service.UpdateUser(&user); err != nil {
		utils.RespondWithError(w, http.StatusInternalServerError, "Failed to update user")
		return
	}
	utils.RespondWithJSON(w, http.StatusOK, user)
}

// @Summary Delete a user
// @Description Delete a user by their ID
// @Tags users
// @Accept  json
// @Produce  json
// @Param id path int true "User ID"
// @Success 200 {object} map[string]string
// @Failure 400 {object} utils.ErrorResponse
// @Failure 500 {object} utils.ErrorResponse
// @Router /users/{id} [delete]
func (api *APIv1) deleteUserHandler(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id, err := strconv.Atoi(vars["id"])
	if err != nil {
		utils.RespondWithError(w, http.StatusBadRequest, "Invalid user ID")
		return
	}
	if err := api.service.DeleteUser(id); err != nil {
		utils.RespondWithError(w, http.StatusInternalServerError, "Failed to delete user")
		return
	}
	utils.RespondWithJSON(w, http.StatusOK, map[string]string{"result": "success"})
}

// @Summary Create a new leave request
// @Description Create a new leave request with the input payload
// @Tags leave-requests
// @Accept  json
// @Produce  json
// @Param request body models.LeaveRequest true "Create leave request"
// @Success 201 {object} models.LeaveRequest
// @Failure 400 {object} utils.ErrorResponse
// @Failure 500 {object} utils.ErrorResponse
// @Router /leave-requests [post]
func (api *APIv1) createLeaveRequestHandler(w http.ResponseWriter, r *http.Request) {
	var request models.LeaveRequest
	if err := json.NewDecoder(r.Body).Decode(&request); err != nil {
		utils.RespondWithError(w, http.StatusBadRequest, "Invalid request payload")
		return
	}
	if err := api.service.CreateLeaveRequest(&request); err != nil {
		utils.RespondWithError(w, http.StatusInternalServerError, "Failed to create leave request")
		return
	}
	utils.RespondWithJSON(w, http.StatusCreated, request)
}

// @Summary Get a leave request by ID
// @Description Get a leave request by its ID
// @Tags leave-requests
// @Accept  json
// @Produce  json
// @Param id path int true "Leave Request ID"
// @Success 200 {object} models.LeaveRequest
// @Failure 400 {object} utils.ErrorResponse
// @Failure 404 {object} utils.ErrorResponse
// @Router /leave-requests/{id} [get]
func (api *APIv1) getLeaveRequestHandler(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id, err := strconv.Atoi(vars["id"])
	if err != nil {
		utils.RespondWithError(w, http.StatusBadRequest, "Invalid leave request ID")
		return
	}
	request, err := api.service.GetLeaveRequestByID(id)
	if err != nil {
		utils.RespondWithError(w, http.StatusNotFound, "Leave request not found")
		return
	}
	utils.RespondWithJSON(w, http.StatusOK, request)
}

// @Summary Update a leave request
// @Description Update a leave request with the input payload
// @Tags leave-requests
// @Accept  json
// @Produce  json
// @Param id path int true "Leave Request ID"
// @Param request body models.LeaveRequest true "Update leave request"
// @Success 200 {object} models.LeaveRequest
// @Failure 400 {object} utils.ErrorResponse
// @Failure 500 {object} utils.ErrorResponse
// @Router /leave-requests/{id} [put]
func (api *APIv1) updateLeaveRequestHandler(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id, err := strconv.Atoi(vars["id"])
	if err != nil {
		utils.RespondWithError(w, http.StatusBadRequest, "Invalid leave request ID")
		return
	}
	var request models.LeaveRequest
	if err := json.NewDecoder(r.Body).Decode(&request); err != nil {
		utils.RespondWithError(w, http.StatusBadRequest, "Invalid request payload")
		return
	}
	request.ID = id
	if err := api.service.UpdateLeaveRequest(&request); err != nil {
		utils.RespondWithError(w, http.StatusInternalServerError, "Failed to update leave request")
		return
	}
	utils.RespondWithJSON(w, http.StatusOK, request)
}

// @Summary Delete a leave request
// @Description Delete a leave request by its ID
// @Tags leave-requests
// @Accept  json
// @Produce  json
// @Param id path int true "Leave Request ID"
// @Success 200 {object} map[string]string
// @Failure 400 {object} utils.ErrorResponse
// @Failure 500 {object} utils.ErrorResponse
// @Router /leave-requests/{id} [delete]
func (api *APIv1) deleteLeaveRequestHandler(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id, err := strconv.Atoi(vars["id"])
	if err != nil {
		utils.RespondWithError(w, http.StatusBadRequest, "Invalid leave request ID")
		return
	}
	if err := api.service.DeleteLeaveRequest(id); err != nil {
		utils.RespondWithError(w, http.StatusInternalServerError, "Failed to delete leave request")
		return
	}
	utils.RespondWithJSON(w, http.StatusOK, map[string]string{"result": "success"})
}

// @Summary Get leave requests by user ID
// @Description Get all leave requests for a specific user
// @Tags leave-requests
// @Accept  json
// @Produce  json
// @Param userId path int true "User ID"
// @Param page query int false "Page number"
// @Param limit query int false "Number of items per page"
// @Success 200 {array} models.LeaveRequest
// @Failure 400 {object} utils.ErrorResponse
// @Failure 500 {object} utils.ErrorResponse
// @Router /users/{userId}/leave-requests [get]
func (api *APIv1) getLeaveRequestsByUserHandler(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	userID, err := strconv.Atoi(vars["userId"])
	if err != nil {
		utils.RespondWithError(w, http.StatusBadRequest, "Invalid user ID")
		return
	}
	pagination := &models.PaginationQuery{}
	if err := r.ParseForm(); err == nil {
		if page, err := strconv.Atoi(r.FormValue("page")); err == nil {
			pagination.Page = page
		}
		if limit, err := strconv.Atoi(r.FormValue("limit")); err == nil {
			pagination.Limit = limit
		}
	}
	requests, err := api.service.GetLeaveRequestsByUserID(userID, pagination)
	if err != nil {
		utils.RespondWithError(w, http.StatusInternalServerError, "Failed to get leave requests")
		return
	}
	utils.RespondWithJSON(w, http.StatusOK, requests)
}

// @Summary Create a new purchase request
// @Description Create a new purchase request with the input payload
// @Tags purchase-requests
// @Accept  json
// @Produce  json
// @Param request body models.PurchaseRequest true "Create purchase request"
// @Success 201 {object} models.PurchaseRequest
// @Failure 400 {object} utils.ErrorResponse
// @Failure 500 {object} utils.ErrorResponse
// @Router /purchase-requests [post]
func (api *APIv1) createPurchaseRequestHandler(w http.ResponseWriter, r *http.Request) {
	var request models.PurchaseRequest
	if err := json.NewDecoder(r.Body).Decode(&request); err != nil {
		utils.RespondWithError(w, http.StatusBadRequest, "Invalid request payload")
		return
	}
	if err := api.service.CreatePurchaseRequest(&request); err != nil {
		utils.RespondWithError(w, http.StatusInternalServerError, "Failed to create purchase request")
		return
	}
	utils.RespondWithJSON(w, http.StatusCreated, request)
}

// @Summary Get a purchase request by ID
// @Description Get a purchase request by its ID
// @Tags purchase-requests
// @Accept  json
// @Produce  json
// @Param id path int true "Purchase Request ID"
// @Success 200 {object} models.PurchaseRequest
// @Failure 400 {object} utils.ErrorResponse
// @Failure 404 {object} utils.ErrorResponse
// @Router /purchase-requests/{id} [get]
func (api *APIv1) getPurchaseRequestHandler(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id, err := strconv.Atoi(vars["id"])
	if err != nil {
		utils.RespondWithError(w, http.StatusBadRequest, "Invalid purchase request ID")
		return
	}
	request, err := api.service.GetPurchaseRequestByID(id)
	if err != nil {
		utils.RespondWithError(w, http.StatusNotFound, "Purchase request not found")
		return
	}
	utils.RespondWithJSON(w, http.StatusOK, request)
}

// @Summary Update a purchase request
// @Description Update a purchase request with the input payload
// @Tags purchase-requests
// @Accept  json
// @Produce  json
// @Param id path int true "Purchase Request ID"
// @Param request body models.PurchaseRequest true "Update purchase request"
// @Success 200 {object} models.PurchaseRequest
// @Failure 400 {object} utils.ErrorResponse
// @Failure 500 {object} utils.ErrorResponse
// @Router /purchase-requests/{id} [put]
func (api *APIv1) updatePurchaseRequestHandler(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id, err := strconv.Atoi(vars["id"])
	if err != nil {
		utils.RespondWithError(w, http.StatusBadRequest, "Invalid purchase request ID")
		return
	}
	var request models.PurchaseRequest
	if err := json.NewDecoder(r.Body).Decode(&request); err != nil {
		utils.RespondWithError(w, http.StatusBadRequest, "Invalid request payload")
		return
	}
	request.ID = id
	if err := api.service.UpdatePurchaseRequest(&request); err != nil {
		utils.RespondWithError(w, http.StatusInternalServerError, "Failed to update purchase request")
		return
	}
	utils.RespondWithJSON(w, http.StatusOK, request)
}

// @Summary Delete a purchase request
// @Description Delete a purchase request by its ID
// @Tags purchase-requests
// @Accept  json
// @Produce  json
// @Param id path int true "Purchase Request ID"
// @Success 200 {object} map[string]string
// @Failure 400 {object} utils.ErrorResponse
// @Failure 500 {object} utils.ErrorResponse
// @Router /purchase-requests/{id} [delete]
func (api *APIv1) deletePurchaseRequestHandler(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id, err := strconv.Atoi(vars["id"])
	if err != nil {
		utils.RespondWithError(w, http.StatusBadRequest, "Invalid purchase request ID")
		return
	}
	if err := api.service.DeletePurchaseRequest(id); err != nil {
		utils.RespondWithError(w, http.StatusInternalServerError, "Failed to delete purchase request")
		return
	}
	utils.RespondWithJSON(w, http.StatusOK, map[string]string{"result": "success"})
}

// @Summary Get purchase requests by user ID
// @Description Get all purchase requests for a specific user
// @Tags purchase-requests
// @Accept  json
// @Produce  json
// @Param userId path int true "User ID"
// @Param page query int false "Page number"
// @Param limit query int false "Number of items per page"
// @Success 200 {array} models.PurchaseRequest
// @Failure 400 {object} utils.ErrorResponse
// @Failure 500 {object} utils.ErrorResponse
// @Router /users/{userId}/purchase-requests [get]
func (api *APIv1) getPurchaseRequestsByUserHandler(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	userID, err := strconv.Atoi(vars["userId"])
	if err != nil {
		utils.RespondWithError(w, http.StatusBadRequest, "Invalid user ID")
		return
	}
	pagination := &models.PaginationQuery{}
	if err := r.ParseForm(); err == nil {
		if page, err := strconv.Atoi(r.FormValue("page")); err == nil {
			pagination.Page = page
		}
		if limit, err := strconv.Atoi(r.FormValue("limit")); err == nil {
			pagination.Limit = limit
		}
	}
	requests, err := api.service.GetPurchaseRequestsByUserID(userID, pagination)
	if err != nil {
		utils.RespondWithError(w, http.StatusInternalServerError, "Failed to get purchase requests")
		return
	}
	utils.RespondWithJSON(w, http.StatusOK, requests)
}

--- End of backend/internal/api/v1/handlers.go ---

--- Start of backend/internal/service/service.go ---
package service

import (
	"bytes"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"

	"github.com/google/uuid"
	"github.com/mcopur/sap-assist/internal/models"
	"github.com/mcopur/sap-assist/internal/repository"
	"github.com/mcopur/sap-assist/internal/utils"
)

type Service struct {
	repo       *repository.PostgresRepository
	NLPService *NLPService
	httpClient *http.Client
	sapConfig  *SAPConfig
}

type SAPConfig struct {
	BaseURL      string
	ClientID     string
	ClientSecret string
}

func NewService(repo *repository.PostgresRepository, nlpService *NLPService, sapConfig *SAPConfig) *Service {
	return &Service{
		repo:       repo,
		NLPService: nlpService,
		httpClient: &http.Client{},
		sapConfig:  sapConfig,
	}
}

func (s *Service) SendLeaveRequest(personnelNumber, startDate, endDate string) (interface{}, error) {
	url := fmt.Sprintf("%s/sap/opu/odata/sap/ZCXP_LEAVE_REQUEST_SRV/LEAVE_REQUESTSet", s.sapConfig.BaseURL)
	method := "POST"

	requestID := uuid.New().String()
	payload := map[string]interface{}{
		"PersonnelNumber":       personnelNumber,
		"RequestId":             requestID,
		"Status":                "",
		"StatusText":            "",
		"EndDate":               endDate,
		"StartDate":             startDate,
		"RequestOrAttabs":       "",
		"AttabsHours":           "0.00",
		"AttendanceAbsenceDays": "0.00",
		"CalendarDays":          "1.00",
		"PayrollDays":           "0.00",
		"PayrollHours":          "0.00",
		"SubtypeDescription":    "",
		"Deduction":             "",
		"DeductionTooltip":      "",
	}

	jsonPayload, err := json.Marshal(payload)
	if err != nil {
		return nil, fmt.Errorf("error marshaling JSON: %w", err)
	}

	req, err := http.NewRequest(method, url, bytes.NewBuffer(jsonPayload))
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Add("Content-Type", "application/json")
	req.Header.Add("Authorization", fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(s.sapConfig.ClientID+":"+s.sapConfig.ClientSecret))))

	resp, err := s.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading response body: %w", err)
	}

	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusCreated {
		return nil, fmt.Errorf("unexpected status code: %d, body: %s", resp.StatusCode, string(body))
	}

	var result map[string]interface{}
	if err := json.Unmarshal(body, &result); err != nil {
		return nil, fmt.Errorf("error unmarshaling response: %w", err)
	}

	return result, nil
}

func (s *Service) Login(personnelNumber, password string) (string, error) {
	url := fmt.Sprintf("%s/sap/opu/odata/sap/ZCXP_LEAVE_REQUEST_SRV/LEAVE_REQUESTSet", s.sapConfig.BaseURL)
	method := "GET"

	req, err := http.NewRequest(method, url, nil)
	if err != nil {
		return "", err
	}

	auth := base64.StdEncoding.EncodeToString([]byte(personnelNumber + ":" + password))
	req.Header.Add("Authorization", "Basic "+auth)

	resp, err := s.httpClient.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("login failed")
	}

	csrfToken := resp.Header.Get("X-CSRF-Token")
	cookie := resp.Header.Get("Set-Cookie")

	token := fmt.Sprintf("%s:%s:%s:%s", personnelNumber, csrfToken, auth, cookie)
	encodedToken := base64.StdEncoding.EncodeToString([]byte(token))

	return encodedToken, nil
}

// User Service Methods
func (s *Service) CreateUser(user *models.User) error {
	utils.InfoLogger.Printf("Creating user: %s", user.Username)
	err := s.repo.CreateUser(user)
	if err != nil {
		utils.ErrorLogger.Printf("Failed to create user: %v", err)
		return utils.NewAppError(500, "Failed to create user", err)
	}
	return nil
}

func (s *Service) GetUserByID(id int) (*models.User, error) {
	utils.InfoLogger.Printf("Getting user by ID: %d", id)
	user, err := s.repo.GetUserByID(id)
	if err != nil {
		utils.ErrorLogger.Printf("Failed to get user by ID: %v", err)
		return nil, utils.NewAppError(500, "Failed to get user", err)
	}
	return user, nil
}

func (s *Service) UpdateUser(user *models.User) error {
	utils.InfoLogger.Printf("Updating user: %d", user.ID)
	err := s.repo.UpdateUser(user)
	if err != nil {
		utils.ErrorLogger.Printf("Failed to update user: %v", err)
		return utils.NewAppError(500, "Failed to update user", err)
	}
	return nil
}

func (s *Service) DeleteUser(id int) error {
	utils.InfoLogger.Printf("Deleting user: %d", id)
	err := s.repo.DeleteUser(id)
	if err != nil {
		utils.ErrorLogger.Printf("Failed to delete user: %v", err)
		return utils.NewAppError(500, "Failed to delete user", err)
	}
	return nil
}

// Leave Request Service Methods
func (s *Service) CreateLeaveRequest(request *models.LeaveRequest) error {
	utils.InfoLogger.Printf("Creating leave request for user: %d", request.UserID)
	err := s.repo.CreateLeaveRequest(request)
	if err != nil {
		utils.ErrorLogger.Printf("Failed to create leave request: %v", err)
		return utils.NewAppError(500, "Failed to create leave request", err)
	}
	return nil
}

func (s *Service) GetLeaveRequestByID(id int) (*models.LeaveRequest, error) {
	utils.InfoLogger.Printf("Getting leave request by ID: %d", id)
	request, err := s.repo.GetLeaveRequestByID(id)
	if err != nil {
		utils.ErrorLogger.Printf("Failed to get leave request by ID: %v", err)
		return nil, utils.NewAppError(500, "Failed to get leave request", err)
	}
	return request, nil
}

func (s *Service) GetLeaveRequestsByUserID(userID int, pagination *models.PaginationQuery) ([]*models.LeaveRequest, error) {
	utils.InfoLogger.Printf("Getting leave requests for user: %d", userID)
	requests, err := s.repo.GetLeaveRequestsByUserIDWithPagination(userID, pagination.GetOffset(), pagination.GetLimit())
	if err != nil {
		utils.ErrorLogger.Printf("Failed to get leave requests for user: %v", err)
		return nil, utils.NewAppError(500, "Failed to get leave requests", err)
	}
	return requests, nil
}

func (s *Service) UpdateLeaveRequest(request *models.LeaveRequest) error {
	utils.InfoLogger.Printf("Updating leave request: %d", request.ID)
	err := s.repo.UpdateLeaveRequest(request)
	if err != nil {
		utils.ErrorLogger.Printf("Failed to update leave request: %v", err)
		return utils.NewAppError(500, "Failed to update leave request", err)
	}
	return nil
}

func (s *Service) DeleteLeaveRequest(id int) error {
	utils.InfoLogger.Printf("Deleting leave request: %d", id)
	err := s.repo.DeleteLeaveRequest(id)
	if err != nil {
		utils.ErrorLogger.Printf("Failed to delete leave request: %v", err)
		return utils.NewAppError(500, "Failed to delete leave request", err)
	}
	return nil
}

// Purchase Request Service Methods
func (s *Service) CreatePurchaseRequest(request *models.PurchaseRequest) error {
	utils.InfoLogger.Printf("Creating purchase request for user: %d", request.UserID)
	err := s.repo.CreatePurchaseRequest(request)
	if err != nil {
		utils.ErrorLogger.Printf("Failed to create purchase request: %v", err)
		return utils.NewAppError(500, "Failed to create purchase request", err)
	}
	return nil
}

func (s *Service) GetPurchaseRequestByID(id int) (*models.PurchaseRequest, error) {
	utils.InfoLogger.Printf("Getting purchase request by ID: %d", id)
	request, err := s.repo.GetPurchaseRequestByID(id)
	if err != nil {
		utils.ErrorLogger.Printf("Failed to get purchase request by ID: %v", err)
		return nil, utils.NewAppError(500, "Failed to get purchase request", err)
	}
	return request, nil
}

func (s *Service) GetPurchaseRequestsByUserID(userID int, pagination *models.PaginationQuery) ([]*models.PurchaseRequest, error) {
	utils.InfoLogger.Printf("Getting purchase requests for user: %d", userID)
	requests, err := s.repo.GetPurchaseRequestsByUserIDWithPagination(userID, pagination.GetOffset(), pagination.GetLimit())
	if err != nil {
		utils.ErrorLogger.Printf("Failed to get purchase requests for user: %v", err)
		return nil, utils.NewAppError(500, "Failed to get purchase requests", err)
	}
	return requests, nil
}

func (s *Service) UpdatePurchaseRequest(request *models.PurchaseRequest) error {
	utils.InfoLogger.Printf("Updating purchase request: %d", request.ID)
	err := s.repo.UpdatePurchaseRequest(request)
	if err != nil {
		utils.ErrorLogger.Printf("Failed to update purchase request: %v", err)
		return utils.NewAppError(500, "Failed to update purchase request", err)
	}
	return nil
}

func (s *Service) DeletePurchaseRequest(id int) error {
	utils.InfoLogger.Printf("Deleting purchase request: %d", id)
	err := s.repo.DeletePurchaseRequest(id)
	if err != nil {
		utils.ErrorLogger.Printf("Failed to delete purchase request: %v", err)
		return utils.NewAppError(500, "Failed to delete purchase request", err)
	}
	return nil
}

func (s *Service) ExtractTokenInfo(token string) (string, string, string, string, error) {
	decodedToken, err := base64.StdEncoding.DecodeString(token)
	if err != nil {
		return "", "", "", "", err
	}

	parts := strings.Split(string(decodedToken), ":")
	if len(parts) != 4 {
		return "", "", "", "", fmt.Errorf("invalid token format")
	}

	return parts[0], parts[1], parts[2], parts[3], nil
}

func (s *Service) ProcessMessage(input models.UserInput) (*models.IntentResponse, error) {
	return s.NLPService.ProcessMessage(input)
}

--- End of backend/internal/service/service.go ---

--- Start of backend/internal/service/nlp_service.go ---
package service

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"

	"github.com/mcopur/sap-assist/internal/models"
)

type NLPService struct {
	baseURL string
	client  *http.Client
}

func NewNLPService(baseURL string) *NLPService {
	return &NLPService{
		baseURL: baseURL,
		client:  &http.Client{},
	}
}

func (s *NLPService) ProcessMessage(input models.UserInput) (*models.IntentResponse, error) {
	url := fmt.Sprintf("%s/process", s.baseURL)
	requestBody, err := json.Marshal(map[string]string{"text": input.Text})
	if err != nil {
		return nil, fmt.Errorf("error marshaling request: %v", err)
	}

	resp, err := s.client.Post(url, "application/json", bytes.NewBuffer(requestBody))
	if err != nil {
		return nil, fmt.Errorf("error sending request to NLP service: %v", err)
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading response body: %v", err)
	}

	if resp.StatusCode != http.StatusOK {
		var errorResponse struct {
			Error   string `json:"error"`
			Details string `json:"details"`
		}
		if err := json.Unmarshal(body, &errorResponse); err == nil {
			return nil, fmt.Errorf("NLP service error: %s, details: %s", errorResponse.Error, errorResponse.Details)
		}
		return nil, fmt.Errorf("NLP service returned non-200 status code: %d, body: %s", resp.StatusCode, string(body))
	}

	var response models.IntentResponse
	if err := json.Unmarshal(body, &response); err != nil {
		return nil, fmt.Errorf("error unmarshaling response: %v", err)
	}

	return &response, nil
}

--- End of backend/internal/service/nlp_service.go ---

--- Start of docs/swagger.yaml ---
basePath: /api/v1
definitions:
  models.LeaveRequest:
    properties:
      created_at:
        type: string
      end_date:
        type: string
      id:
        type: integer
      leave_type:
        type: string
      reason:
        type: string
      start_date:
        type: string
      status:
        type: string
      updated_at:
        type: string
      user_id:
        type: integer
    type: object
  models.PurchaseRequest:
    properties:
      created_at:
        type: string
      estimated_cost:
        type: number
      id:
        type: integer
      item_name:
        type: string
      quantity:
        type: integer
      reason:
        type: string
      status:
        type: string
      updated_at:
        type: string
      user_id:
        type: integer
    type: object
  models.User:
    properties:
      created_at:
        type: string
      email:
        type: string
      first_name:
        type: string
      id:
        type: integer
      last_name:
        type: string
      role:
        enum:
        - admin
        - user
        type: string
      updated_at:
        type: string
      username:
        maxLength: 50
        minLength: 3
        type: string
    required:
    - email
    - first_name
    - last_name
    - role
    - username
    type: object
  utils.ErrorResponse:
    properties:
      message:
        type: string
    type: object
host: localhost:8080
info:
  contact:
    email: support@swagger.io
    name: API Support
    url: http://www.swagger.io/support
  description: This is a sample server for SAP Assist application.
  license:
    name: Apache 2.0
    url: http://www.apache.org/licenses/LICENSE-2.0.html
  termsOfService: http://swagger.io/terms/
  title: SAP Assist API
  version: "1.0"
paths:
  /leave-requests:
    post:
      consumes:
      - application/json
      description: Create a new leave request with the input payload
      parameters:
      - description: Create leave request
        in: body
        name: request
        required: true
        schema:
          $ref: '#/definitions/models.LeaveRequest'
      produces:
      - application/json
      responses:
        "201":
          description: Created
          schema:
            $ref: '#/definitions/models.LeaveRequest'
        "400":
          description: Bad Request
          schema:
            $ref: '#/definitions/utils.ErrorResponse'
        "500":
          description: Internal Server Error
          schema:
            $ref: '#/definitions/utils.ErrorResponse'
      summary: Create a new leave request
      tags:
      - leave-requests
  /leave-requests/{id}:
    delete:
      consumes:
      - application/json
      description: Delete a leave request by its ID
      parameters:
      - description: Leave Request ID
        in: path
        name: id
        required: true
        type: integer
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            additionalProperties:
              type: string
            type: object
        "400":
          description: Bad Request
          schema:
            $ref: '#/definitions/utils.ErrorResponse'
        "500":
          description: Internal Server Error
          schema:
            $ref: '#/definitions/utils.ErrorResponse'
      summary: Delete a leave request
      tags:
      - leave-requests
    get:
      consumes:
      - application/json
      description: Get a leave request by its ID
      parameters:
      - description: Leave Request ID
        in: path
        name: id
        required: true
        type: integer
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/models.LeaveRequest'
        "400":
          description: Bad Request
          schema:
            $ref: '#/definitions/utils.ErrorResponse'
        "404":
          description: Not Found
          schema:
            $ref: '#/definitions/utils.ErrorResponse'
      summary: Get a leave request by ID
      tags:
      - leave-requests
    put:
      consumes:
      - application/json
      description: Update a leave request with the input payload
      parameters:
      - description: Leave Request ID
        in: path
        name: id
        required: true
        type: integer
      - description: Update leave request
        in: body
        name: request
        required: true
        schema:
          $ref: '#/definitions/models.LeaveRequest'
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/models.LeaveRequest'
        "400":
          description: Bad Request
          schema:
            $ref: '#/definitions/utils.ErrorResponse'
        "500":
          description: Internal Server Error
          schema:
            $ref: '#/definitions/utils.ErrorResponse'
      summary: Update a leave request
      tags:
      - leave-requests
  /purchase-requests:
    post:
      consumes:
      - application/json
      description: Create a new purchase request with the input payload
      parameters:
      - description: Create purchase request
        in: body
        name: request
        required: true
        schema:
          $ref: '#/definitions/models.PurchaseRequest'
      produces:
      - application/json
      responses:
        "201":
          description: Created
          schema:
            $ref: '#/definitions/models.PurchaseRequest'
        "400":
          description: Bad Request
          schema:
            $ref: '#/definitions/utils.ErrorResponse'
        "500":
          description: Internal Server Error
          schema:
            $ref: '#/definitions/utils.ErrorResponse'
      summary: Create a new purchase request
      tags:
      - purchase-requests
  /purchase-requests/{id}:
    delete:
      consumes:
      - application/json
      description: Delete a purchase request by its ID
      parameters:
      - description: Purchase Request ID
        in: path
        name: id
        required: true
        type: integer
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            additionalProperties:
              type: string
            type: object
        "400":
          description: Bad Request
          schema:
            $ref: '#/definitions/utils.ErrorResponse'
        "500":
          description: Internal Server Error
          schema:
            $ref: '#/definitions/utils.ErrorResponse'
      summary: Delete a purchase request
      tags:
      - purchase-requests
    get:
      consumes:
      - application/json
      description: Get a purchase request by its ID
      parameters:
      - description: Purchase Request ID
        in: path
        name: id
        required: true
        type: integer
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/models.PurchaseRequest'
        "400":
          description: Bad Request
          schema:
            $ref: '#/definitions/utils.ErrorResponse'
        "404":
          description: Not Found
          schema:
            $ref: '#/definitions/utils.ErrorResponse'
      summary: Get a purchase request by ID
      tags:
      - purchase-requests
    put:
      consumes:
      - application/json
      description: Update a purchase request with the input payload
      parameters:
      - description: Purchase Request ID
        in: path
        name: id
        required: true
        type: integer
      - description: Update purchase request
        in: body
        name: request
        required: true
        schema:
          $ref: '#/definitions/models.PurchaseRequest'
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/models.PurchaseRequest'
        "400":
          description: Bad Request
          schema:
            $ref: '#/definitions/utils.ErrorResponse'
        "500":
          description: Internal Server Error
          schema:
            $ref: '#/definitions/utils.ErrorResponse'
      summary: Update a purchase request
      tags:
      - purchase-requests
  /users:
    post:
      consumes:
      - application/json
      description: Create a new user with the input payload
      parameters:
      - description: Create user
        in: body
        name: user
        required: true
        schema:
          $ref: '#/definitions/models.User'
      produces:
      - application/json
      responses:
        "201":
          description: Created
          schema:
            $ref: '#/definitions/models.User'
        "400":
          description: Bad Request
          schema:
            $ref: '#/definitions/utils.ErrorResponse'
        "500":
          description: Internal Server Error
          schema:
            $ref: '#/definitions/utils.ErrorResponse'
      summary: Create a new user
      tags:
      - users
  /users/{id}:
    delete:
      consumes:
      - application/json
      description: Delete a user by their ID
      parameters:
      - description: User ID
        in: path
        name: id
        required: true
        type: integer
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            additionalProperties:
              type: string
            type: object
        "400":
          description: Bad Request
          schema:
            $ref: '#/definitions/utils.ErrorResponse'
        "500":
          description: Internal Server Error
          schema:
            $ref: '#/definitions/utils.ErrorResponse'
      summary: Delete a user
      tags:
      - users
    get:
      consumes:
      - application/json
      description: Get a user by their ID
      parameters:
      - description: User ID
        in: path
        name: id
        required: true
        type: integer
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/models.User'
        "400":
          description: Bad Request
          schema:
            $ref: '#/definitions/utils.ErrorResponse'
        "404":
          description: Not Found
          schema:
            $ref: '#/definitions/utils.ErrorResponse'
      summary: Get a user by ID
      tags:
      - users
    put:
      consumes:
      - application/json
      description: Update a user with the input payload
      parameters:
      - description: User ID
        in: path
        name: id
        required: true
        type: integer
      - description: Update user
        in: body
        name: user
        required: true
        schema:
          $ref: '#/definitions/models.User'
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/models.User'
        "400":
          description: Bad Request
          schema:
            $ref: '#/definitions/utils.ErrorResponse'
        "500":
          description: Internal Server Error
          schema:
            $ref: '#/definitions/utils.ErrorResponse'
      summary: Update a user
      tags:
      - users
  /users/{userId}/leave-requests:
    get:
      consumes:
      - application/json
      description: Get all leave requests for a specific user
      parameters:
      - description: User ID
        in: path
        name: userId
        required: true
        type: integer
      - description: Page number
        in: query
        name: page
        type: integer
      - description: Number of items per page
        in: query
        name: limit
        type: integer
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            items:
              $ref: '#/definitions/models.LeaveRequest'
            type: array
        "400":
          description: Bad Request
          schema:
            $ref: '#/definitions/utils.ErrorResponse'
        "500":
          description: Internal Server Error
          schema:
            $ref: '#/definitions/utils.ErrorResponse'
      summary: Get leave requests by user ID
      tags:
      - leave-requests
  /users/{userId}/purchase-requests:
    get:
      consumes:
      - application/json
      description: Get all purchase requests for a specific user
      parameters:
      - description: User ID
        in: path
        name: userId
        required: true
        type: integer
      - description: Page number
        in: query
        name: page
        type: integer
      - description: Number of items per page
        in: query
        name: limit
        type: integer
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            items:
              $ref: '#/definitions/models.PurchaseRequest'
            type: array
        "400":
          description: Bad Request
          schema:
            $ref: '#/definitions/utils.ErrorResponse'
        "500":
          description: Internal Server Error
          schema:
            $ref: '#/definitions/utils.ErrorResponse'
      summary: Get purchase requests by user ID
      tags:
      - purchase-requests
swagger: "2.0"

--- End of docs/swagger.yaml ---

--- Start of docs/docs.go ---
// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://swagger.io/terms/",
        "contact": {
            "name": "API Support",
            "url": "http://www.swagger.io/support",
            "email": "support@swagger.io"
        },
        "license": {
            "name": "Apache 2.0",
            "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/leave-requests": {
            "post": {
                "description": "Create a new leave request with the input payload",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "leave-requests"
                ],
                "summary": "Create a new leave request",
                "parameters": [
                    {
                        "description": "Create leave request",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.LeaveRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/models.LeaveRequest"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/leave-requests/{id}": {
            "get": {
                "description": "Get a leave request by its ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "leave-requests"
                ],
                "summary": "Get a leave request by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Leave Request ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.LeaveRequest"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    }
                }
            },
            "put": {
                "description": "Update a leave request with the input payload",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "leave-requests"
                ],
                "summary": "Update a leave request",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Leave Request ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Update leave request",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.LeaveRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.LeaveRequest"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    }
                }
            },
            "delete": {
                "description": "Delete a leave request by its ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "leave-requests"
                ],
                "summary": "Delete a leave request",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Leave Request ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/purchase-requests": {
            "post": {
                "description": "Create a new purchase request with the input payload",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "purchase-requests"
                ],
                "summary": "Create a new purchase request",
                "parameters": [
                    {
                        "description": "Create purchase request",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.PurchaseRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/models.PurchaseRequest"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/purchase-requests/{id}": {
            "get": {
                "description": "Get a purchase request by its ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "purchase-requests"
                ],
                "summary": "Get a purchase request by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Purchase Request ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.PurchaseRequest"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    }
                }
            },
            "put": {
                "description": "Update a purchase request with the input payload",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "purchase-requests"
                ],
                "summary": "Update a purchase request",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Purchase Request ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Update purchase request",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.PurchaseRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.PurchaseRequest"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    }
                }
            },
            "delete": {
                "description": "Delete a purchase request by its ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "purchase-requests"
                ],
                "summary": "Delete a purchase request",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Purchase Request ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/users": {
            "post": {
                "description": "Create a new user with the input payload",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Create a new user",
                "parameters": [
                    {
                        "description": "Create user",
                        "name": "user",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.User"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/models.User"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/users/{id}": {
            "get": {
                "description": "Get a user by their ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Get a user by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "User ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.User"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    }
                }
            },
            "put": {
                "description": "Update a user with the input payload",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Update a user",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "User ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Update user",
                        "name": "user",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.User"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.User"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    }
                }
            },
            "delete": {
                "description": "Delete a user by their ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Delete a user",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "User ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/users/{userId}/leave-requests": {
            "get": {
                "description": "Get all leave requests for a specific user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "leave-requests"
                ],
                "summary": "Get leave requests by user ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "User ID",
                        "name": "userId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "Page number",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Number of items per page",
                        "name": "limit",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/models.LeaveRequest"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/users/{userId}/purchase-requests": {
            "get": {
                "description": "Get all purchase requests for a specific user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "purchase-requests"
                ],
                "summary": "Get purchase requests by user ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "User ID",
                        "name": "userId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "Page number",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Number of items per page",
                        "name": "limit",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/models.PurchaseRequest"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "models.LeaveRequest": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "end_date": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "leave_type": {
                    "type": "string"
                },
                "reason": {
                    "type": "string"
                },
                "start_date": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                },
                "user_id": {
                    "type": "integer"
                }
            }
        },
        "models.PurchaseRequest": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "estimated_cost": {
                    "type": "number"
                },
                "id": {
                    "type": "integer"
                },
                "item_name": {
                    "type": "string"
                },
                "quantity": {
                    "type": "integer"
                },
                "reason": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                },
                "user_id": {
                    "type": "integer"
                }
            }
        },
        "models.User": {
            "type": "object",
            "required": [
                "email",
                "first_name",
                "last_name",
                "role",
                "username"
            ],
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "first_name": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "last_name": {
                    "type": "string"
                },
                "role": {
                    "type": "string",
                    "enum": [
                        "admin",
                        "user"
                    ]
                },
                "updated_at": {
                    "type": "string"
                },
                "username": {
                    "type": "string",
                    "maxLength": 50,
                    "minLength": 3
                }
            }
        },
        "utils.ErrorResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &swag.Spec{
	Version:          "1.0",
	Host:             "localhost:8080",
	BasePath:         "/api/v1",
	Schemes:          []string{},
	Title:            "SAP Assist API",
	Description:      "This is a sample server for SAP Assist application.",
	InfoInstanceName: "swagger",
	SwaggerTemplate:  docTemplate,
	LeftDelim:        "{{",
	RightDelim:       "}}",
}

func init() {
	swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}

--- End of docs/docs.go ---

--- Start of sap-assist-frontend/index.html ---
<!DOCTYPE html>
<html lang="en" style="height: 100%;">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SAP Assist</title>
  </head>
  <body style="margin: 0; height: 100%;">
    <div id="root" style="height: 100%;"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
--- End of sap-assist-frontend/index.html ---

--- Start of sap-assist-frontend/README.md ---
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type aware lint rules:

- Configure the top-level `parserOptions` property like this:

```js
export default {
  // other rules...
  parserOptions: {
    ecmaVersion: 'latest',
    sourceType: 'module',
    project: ['./tsconfig.json', './tsconfig.node.json', './tsconfig.app.json'],
    tsconfigRootDir: __dirname,
  },
}
```

- Replace `plugin:@typescript-eslint/recommended` to `plugin:@typescript-eslint/recommended-type-checked` or `plugin:@typescript-eslint/strict-type-checked`
- Optionally add `plugin:@typescript-eslint/stylistic-type-checked`
- Install [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) and add `plugin:react/recommended` & `plugin:react/jsx-runtime` to the `extends` list

--- End of sap-assist-frontend/README.md ---

--- Start of sap-assist-frontend/package.json ---
{
  "name": "sap-assist-frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview",
    "start": "vite"
  },
  "dependencies": {
    "@emotion/react": "^11.12.0",
    "@emotion/styled": "^11.12.0",
    "@mui/icons-material": "^5.16.4",
    "@mui/material": "^5.16.4",
    "@reduxjs/toolkit": "^2.2.7",
    "axios": "^1.7.2",
    "cors": "^2.8.5",
    "lucide-react": "^0.438.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-redux": "^9.1.2"
  },
  "devDependencies": {
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@typescript-eslint/eslint-plugin": "^7.15.0",
    "@typescript-eslint/parser": "^7.15.0",
    "@vitejs/plugin-react": "^4.3.1",
    "eslint": "^8.57.0",
    "eslint-plugin-react-hooks": "^4.6.2",
    "eslint-plugin-react-refresh": "^0.4.7",
    "typescript": "^5.2.2",
    "vite": "^5.3.4"
  }
}

--- End of sap-assist-frontend/package.json ---

--- Start of sap-assist-frontend/vite.config.ts ---
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
})

--- End of sap-assist-frontend/vite.config.ts ---

--- Start of sap-assist-frontend/src/App.tsx ---
import React from 'react';
import { useSelector } from 'react-redux';
import { RootState } from './store';
import { ThemeProvider, createTheme, CssBaseline, AppBar, Toolbar, Typography, Avatar, Button, Box } from '@mui/material';
import { blue, grey } from '@mui/material/colors';
import ChatInterface from './components/ChatInterface';

const theme = createTheme({
  palette: {
    primary: {
      main: blue[700],
    },
    secondary: {
      main: grey[300],
    },
    background: {
      default: '#f5f5f5',
    },
  },
  typography: {
    fontFamily: '"Roboto", "Helvetica", "Arial", sans-serif',
    h6: {
      fontWeight: 600,
    },
  },
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          textTransform: 'none',
        },
      },
    },
    MuiPaper: {
      styleOverrides: {
        root: {
          boxShadow: '0 3px 10px rgba(0,0,0,0.08)',
        },
      },
    },
  },
});

const App: React.FC = () => {
  const auth = useSelector((state: RootState) => state.auth);

  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh' }}>
        <AppBar position="static" elevation={0}>
          <Toolbar>
            <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
              SAP Assist
            </Typography>
            {auth.isAuthenticated && auth.user && (
              <Box sx={{ display: 'flex', alignItems: 'center', mr: 2 }}>
                <Avatar sx={{ width: 32, height: 32, mr: 1 }}>{auth.user.name[0]}</Avatar>
                <Typography variant="body2">{auth.user.name}</Typography>
              </Box>
            )}
            <Button color="inherit">
              {auth.isAuthenticated ? 'Logout' : 'Login'}
            </Button>
          </Toolbar>
        </AppBar>
        <Box sx={{ flexGrow: 1, overflow: 'hidden' }}>
          <ChatInterface />
        </Box>
      </Box>
    </ThemeProvider>
  );
};

export default App;
--- End of sap-assist-frontend/src/App.tsx ---

--- Start of sap-assist-frontend/src/main.tsx ---
import React from 'react'
import ReactDOM from 'react-dom/client'
import { Provider } from 'react-redux'
import { store } from './store'
import App from './App.tsx'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <Provider store={store}>
      <App />
    </Provider>
  </React.StrictMode>,
)
--- End of sap-assist-frontend/src/main.tsx ---

--- Start of sap-assist-frontend/src/App.css ---
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

--- End of sap-assist-frontend/src/App.css ---

--- Start of sap-assist-frontend/src/index.css ---
:root {
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

html, body, #root {
  height: 100%;
  width: 100%;
  margin: 0;
  padding: 0;
}

body {
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}

button:hover {
  border-color: #646cff;
}

button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}

a:hover {
  color: #535bf2;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}

#root {
  display: flex;
  flex-direction: column;
}

::-webkit-scrollbar {
  width: 10px;
}

::-webkit-scrollbar-track {
  background: #f1f1f1;
}

::-webkit-scrollbar-thumb {
  background: #888;
}

::-webkit-scrollbar-thumb:hover {
  background: #555;
}
--- End of sap-assist-frontend/src/index.css ---

--- Start of sap-assist-frontend/src/vite-env.d.ts ---
/// <reference types="vite/client" />

--- End of sap-assist-frontend/src/vite-env.d.ts ---

--- Start of sap-assist-frontend/src/theme.ts ---
// src/theme.ts

import { createTheme } from '@mui/material/styles';

const theme = createTheme({
  palette: {
    primary: {
      main: '#0050B3', // Koyu mavi
      light: '#E6F7FF',
      dark: '#003A8C',
    },
    secondary: {
      main: '#52C41A', // Yeşil
      light: '#F6FFED',
      dark: '#389E0D',
    },
    background: {
      default: '#F0F2F5',
      paper: '#FFFFFF',
    },
    text: {
      primary: '#262626',
      secondary: '#8C8C8C',
    },
  },
  typography: {
    fontFamily: [
      'Roboto',
      'Arial',
      'sans-serif',
    ].join(','),
    h1: {
      fontSize: '2.5rem',
      fontWeight: 500,
    },
    h2: {
      fontSize: '2rem',
      fontWeight: 500,
    },
    h3: {
      fontSize: '1.75rem',
      fontWeight: 500,
    },
    h4: {
      fontSize: '1.5rem',
      fontWeight: 500,
    },
    h5: {
      fontSize: '1.25rem',
      fontWeight: 500,
    },
    h6: {
      fontSize: '1rem',
      fontWeight: 500,
    },
    body1: {
      fontSize: '1rem',
    },
    body2: {
      fontSize: '0.875rem',
    },
  },
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          textTransform: 'none',
        },
      },
    },
  },
});

export default theme;
--- End of sap-assist-frontend/src/theme.ts ---

--- Start of sap-assist-frontend/src/types/index.ts ---
// sap-assist-frontend/src/types/index.ts
export interface Message {
  text: string;
  isUser: boolean;
  intent?: string;
  timestamp?: number;
}
--- End of sap-assist-frontend/src/types/index.ts ---

--- Start of sap-assist-frontend/src/styles/theme.ts ---
// sap-assist-frontend/src/styles/theme.ts
import { createTheme } from '@mui/material/styles';

const theme = createTheme({
  palette: {
    primary: {
      main: '#1976d2',
    },
    secondary: {
      main: '#dc004e',
    },
  },
});

export default theme;
--- End of sap-assist-frontend/src/styles/theme.ts ---

--- Start of sap-assist-frontend/src/components/ChatInterface.tsx ---
import React, { useRef, useEffect } from 'react';
import { Box, Paper, CircularProgress, Button, useTheme, useMediaQuery, Typography } from '@mui/material';
import MessageList from './MessageList';
import UserInput from './UserInput';
import SuggestionChips from './SuggestionChips';
import { useSelector, useDispatch } from 'react-redux';
import { RootState, AppDispatch } from '../store';
import { sendMessage, resetChat } from '../store/chatSlice';
import { RefreshCw as ResetIcon } from 'lucide-react';

const ChatInterface: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const { messages, status } = useSelector((state: RootState) => state.chat);
  const messagesEndRef = useRef<null | HTMLDivElement>(null);
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  useEffect(scrollToBottom, [messages]);

  const handleSendMessage = (message: string) => {
    dispatch(sendMessage(message));
  };

  const handleResetChat = () => {
    dispatch(resetChat());
  };

  const suggestions = [
    "What's my leave balance?",
    "I want to request a leave",
    "Show my recent purchase requests",
    "How do I submit a new purchase request?"
  ];

  const handleSuggestionClick = (suggestion: string) => {
    dispatch(sendMessage(suggestion));
  };

  return (
    <Box sx={{ 
      height: 'calc(100vh - 64px)', 
      display: 'flex', 
      flexDirection: 'column',
      maxWidth: '1200px',
      margin: '0 auto',
      width: '100%',
      padding: theme.spacing(3),
    }}>
      <Paper elevation={0} sx={{ 
        flexGrow: 1, 
        display: 'flex', 
        flexDirection: 'column',
        overflow: 'hidden',
        borderRadius: theme.shape.borderRadius,
        border: `1px solid ${theme.palette.divider}`,
      }}>
        <Box sx={{ p: 2, borderBottom: `1px solid ${theme.palette.divider}` }}>
          <Typography variant="h6">Chat Assistant</Typography>
        </Box>
        <Box sx={{ flexGrow: 1, overflow: 'auto', p: 2 }}>
          <MessageList messages={messages} />
          {status === 'loading' && (
            <Box display="flex" justifyContent="center" mt={2}>
              <CircularProgress size={24} />
            </Box>
          )}
          <div ref={messagesEndRef} />
        </Box>
        <Box sx={{ p: 2, backgroundColor: 'background.default', borderTop: `1px solid ${theme.palette.divider}` }}>
          <SuggestionChips 
            suggestions={suggestions} 
            onSuggestionClick={handleSuggestionClick} 
            isMobile={isMobile}
          />
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
            <Button 
              variant="outlined" 
              onClick={handleResetChat}
              size={isMobile ? "small" : "medium"}
              startIcon={<ResetIcon />}
            >
              Reset Chat
            </Button>
          </Box>
          <UserInput onSendMessage={handleSendMessage} disabled={status === 'loading'} />
        </Box>
      </Paper>
    </Box>
  );
};

export default ChatInterface;
--- End of sap-assist-frontend/src/components/ChatInterface.tsx ---

--- Start of sap-assist-frontend/src/components/SuggestionChips.tsx ---
import React from 'react';
import { Chip, Box, Typography, useTheme } from '@mui/material';

interface SuggestionChipsProps {
  suggestions: string[];
  onSuggestionClick: (suggestion: string) => void;
  isMobile: boolean;
}

const SuggestionChips: React.FC<SuggestionChipsProps> = ({ suggestions, onSuggestionClick, isMobile }) => {
  const theme = useTheme();

  return (
    <Box sx={{ my: 2 }}>
      <Typography variant={isMobile ? "body2" : "subtitle2"} sx={{ mb: 1 }}>Suggested Actions:</Typography>
      <Box sx={{ 
        display: 'flex', 
        flexWrap: 'wrap', 
        gap: 1,
        justifyContent: isMobile ? 'center' : 'flex-start'
      }}>
        {suggestions.map((suggestion, index) => (
          <Chip
            key={index}
            label={suggestion}
            onClick={() => onSuggestionClick(suggestion)}
            variant="outlined"
            color="primary"
            size={isMobile ? "small" : "medium"}
            sx={{ 
              '&:hover': { 
                backgroundColor: 'primary.light',
                color: 'primary.contrastText'
              },
              transition: theme.transitions.create(['background-color', 'color'], {
                duration: theme.transitions.duration.short,
              }),
            }}
          />
        ))}
      </Box>
    </Box>
  );
};

export default SuggestionChips;
--- End of sap-assist-frontend/src/components/SuggestionChips.tsx ---

--- Start of sap-assist-frontend/src/components/Login.tsx ---
// src/components/Login.tsx
import React, { useState } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { login } from '../store/authSlice';
import { Box, TextField, Button, Typography, Paper, Container, Alert } from '@mui/material';
import { AppDispatch, RootState } from '../store';

const Login: React.FC = () => {
  const [personnelNumber, setPersonnelNumber] = useState('');
  const [password, setPassword] = useState('');
  const dispatch = useDispatch<AppDispatch>();
  const error = useSelector((state: RootState) => state.auth.error);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    dispatch(login({ personnelNumber, password }));
  };

  return (
    <Box
      sx={{
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'center',
        alignItems: 'center',
        width: '100%',
        height: '100%',
        bgcolor: 'background.default',
      }}
    >
      <Container maxWidth="xs">
        <Paper elevation={3} sx={{ padding: 4 }}>
          <Typography component="h1" variant="h5" align="center" gutterBottom>
            Login
          </Typography>
          {error && (
            <Alert severity="error" sx={{ mb: 2 }}>
              {error}
            </Alert>
          )}
          <Box component="form" onSubmit={handleSubmit} noValidate sx={{ mt: 1 }}>
            <TextField
              margin="normal"
              required
              fullWidth
              id="personnelNumber"
              label="Personnel Number"
              name="personnelNumber"
              autoComplete="username"
              autoFocus
              value={personnelNumber}
              onChange={(e) => setPersonnelNumber(e.target.value)}
            />
            <TextField
              margin="normal"
              required
              fullWidth
              name="password"
              label="Password"
              type="password"
              id="password"
              autoComplete="current-password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
            />
            <Button
              type="submit"
              fullWidth
              variant="contained"
              sx={{ mt: 3, mb: 2 }}
            >
              Sign In
            </Button>
          </Box>
        </Paper>
      </Container>
    </Box>
  );
};

export default Login;
--- End of sap-assist-frontend/src/components/Login.tsx ---

--- Start of sap-assist-frontend/src/components/UserInput.tsx ---
import React, { useState, useRef, useEffect } from 'react';
import { Box, TextField, IconButton, useTheme, useMediaQuery } from '@mui/material';
import SendIcon from '@mui/icons-material/Send';

interface UserInputProps {
  onSendMessage: (message: string) => void;
  disabled?: boolean;
}

const UserInput: React.FC<UserInputProps> = ({ onSendMessage, disabled = false }) => {
  const [message, setMessage] = useState('');
  const inputRef = useRef<HTMLInputElement>(null);
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

  useEffect(() => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  }, []);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (message.trim() && !disabled) {
      onSendMessage(message);
      setMessage('');
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      handleSubmit(e);
    }
  };

  return (
    <Box component="form" onSubmit={handleSubmit} sx={{ 
      display: 'flex',
      alignItems: 'center',
      backgroundColor: 'background.paper',
      borderRadius: theme.shape.borderRadius,
      border: `1px solid ${theme.palette.divider}`,
      overflow: 'hidden',
    }}>
      <TextField
        fullWidth
        variant="standard"
        placeholder="Type your message here..."
        value={message}
        onChange={(e) => setMessage(e.target.value)}
        onKeyPress={handleKeyPress}
        disabled={disabled}
        inputRef={inputRef}
        multiline
        maxRows={4}
        InputProps={{
          disableUnderline: true,
        }}
        sx={{
          px: 2,
          py: 1,
        }}
      />
      <IconButton 
        type="submit" 
        color="primary" 
        disabled={disabled || !message.trim()}
        size={isMobile ? "small" : "medium"}
        sx={{ mr: 1 }}
      >
        <SendIcon />
      </IconButton>
    </Box>
  );
};

export default UserInput;
--- End of sap-assist-frontend/src/components/UserInput.tsx ---

--- Start of sap-assist-frontend/src/components/MessageList.tsx ---
import React from 'react';
import { List, ListItem, Paper, Typography, Avatar, Box } from '@mui/material';
import { Message } from '../types';

interface MessageListProps {
  messages: Message[];
}

const MessageList: React.FC<MessageListProps> = ({ messages }) => {
  return (
    <List>
      {messages.map((message, index) => (
        <ListItem key={index} sx={{ 
          display: 'flex', 
          justifyContent: message.isUser ? 'flex-end' : 'flex-start',
          mb: 2,
        }}>
          {!message.isUser && (
            <Avatar sx={{ bgcolor: 'primary.main', mr: 1 }}>AI</Avatar>
          )}
          <Box sx={{ maxWidth: '70%' }}>
            <Paper 
              elevation={0} 
              sx={{ 
                p: 2, 
                bgcolor: message.isUser ? 'primary.light' : 'background.paper',
                borderRadius: message.isUser ? '20px 20px 0 20px' : '20px 20px 20px 0',
                border: (theme) => `1px solid ${theme.palette.divider}`,
              }}
            >
              <Typography variant="body1">{message.text}</Typography>
            </Paper>
            <Typography variant="caption" sx={{ mt: 0.5, display: 'block', textAlign: message.isUser ? 'right' : 'left' }}>
              {new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
            </Typography>
          </Box>
          {message.isUser && (
            <Avatar sx={{ bgcolor: 'secondary.main', ml: 1 }}>U</Avatar>
          )}
        </ListItem>
      ))}
    </List>
  );
};

export default MessageList;
--- End of sap-assist-frontend/src/components/MessageList.tsx ---

--- Start of sap-assist-frontend/src/components/Header.tsx ---
// src/components/Header.tsx

import React from 'react';
import { AppBar, Toolbar, Typography, Button } from '@mui/material';
import { useDispatch } from 'react-redux';
import { logout } from '../store/authSlice';
import { AppDispatch } from '../store';

const Header: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();

  const handleLogout = () => {
    dispatch(logout());
  };

  return (
    <AppBar position="static">
      <Toolbar>
        <Typography variant="h6" style={{ flexGrow: 1 }}>SAP Assist</Typography>
        <Button color="inherit" onClick={handleLogout}>Logout</Button>
      </Toolbar>
    </AppBar>
  );
};

export default Header;
--- End of sap-assist-frontend/src/components/Header.tsx ---

--- Start of sap-assist-frontend/src/components/ErrorBoundary.tsx ---
// sap-assist-frontend/src/components/ErrorBoundary.tsx
import React, { ErrorInfo, ReactNode } from 'react';
import { Box, Typography, Button } from '@mui/material';

interface ErrorBoundaryProps {
  children: ReactNode;
}

interface ErrorBoundaryState {
  hasError: boolean;
}

class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(_: Error): ErrorBoundaryState {
    return { hasError: true };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error("Uncaught error:", error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <Box sx={{ p: 3, textAlign: 'center' }}>
          <Typography variant="h5" gutterBottom>Oops! Something went wrong.</Typography>
          <Button variant="contained" onClick={() => this.setState({ hasError: false })}>
            Try again
          </Button>
        </Box>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;
--- End of sap-assist-frontend/src/components/ErrorBoundary.tsx ---

--- Start of sap-assist-frontend/src/services/sap.ts ---
// sap-assist-frontend/src/services/sap.ts
import { fetchSAPData } from './api';

export const getLeaveBalance = async (employeeId: string) => {
  return await fetchSAPData('leave-balance', { employeeId });
};

export const submitLeaveRequest = async (employeeId: string, startDate: string, endDate: string, leaveType: string) => {
  return await fetchSAPData('submit-leave', { employeeId, startDate, endDate, leaveType });
};

export const getPurchaseRequests = async (employeeId: string) => {
  return await fetchSAPData('purchase-requests', { employeeId });
};

export const submitPurchaseRequest = async (employeeId: string, items: Array<{ name: string, quantity: number }>) => {
  return await fetchSAPData('submit-purchase', { employeeId, items });
};
--- End of sap-assist-frontend/src/services/sap.ts ---

--- Start of sap-assist-frontend/src/services/nlp.ts ---
// src/services/nlp.ts

import { processMessage } from './api';

interface NLPResponse {
  reply: string;
  action?: {
    type: string;
    params: Record<string, any>;
  };
  context?: Record<string, any>;
}

let conversationContext: Record<string, any> = {};

export const processMessageNLP = async (message: string): Promise<NLPResponse> => {
  try {
    console.log('Processing message:', message);
    console.log('Current context:', conversationContext);
    
    const response = await processMessage(message, conversationContext);
    
    console.log('NLP service response:', response);
    
    conversationContext = { ...conversationContext, ...response.context };
    
    console.log('Updated context:', conversationContext);
    
    return response;
  } catch (error) {
    console.error('Error processing message:', error);
    throw new Error('Failed to process message');
  }
}

export const resetContext = () => {
  console.log('Resetting conversation context');
  conversationContext = {};
}
--- End of sap-assist-frontend/src/services/nlp.ts ---

--- Start of sap-assist-frontend/src/services/api.ts ---
// src/services/api.ts

import axios from 'axios';

const API_BASE_URL = 'http://localhost:8080/api/v1';

export const processMessage = async (message: string, context: any) => {
  try {
    console.log('Processing message:', message);
    const response = await axios.post(`${API_BASE_URL}/process`, { 
      text: message,
      context: context
    }, {
      withCredentials: true
    });
    console.log('NLP response:', response.data);
    return response.data;
  } catch (error) {
    console.error('Error processing message:', error);
    if (axios.isAxiosError(error) && error.response) {
      console.error('Response data:', error.response.data);
      console.error('Response status:', error.response.status);
      throw new Error(error.response.data.message || 'An error occurred while processing your request');
    }
    throw new Error('An unknown error occurred');
  }
};

// Mock login function
export const loginUser = async (personnelNumber: string, password: string) => {
  console.log('Attempting login for personnel number:', personnelNumber);
  // Simulate API call delay
  await new Promise(resolve => setTimeout(resolve, 1000));

  // Mock login logic
  if (personnelNumber === '12345' && password === 'password') {
    console.log('Login successful');
    return {
      token: 'mock-jwt-token',
      user: {
        personnelNumber: '12345',
        name: 'Mehmet Copur'
      }
    };
  } else {
    console.error('Login failed: Invalid credentials');
    throw new Error('Invalid credentials');
  }
};

export const fetchSAPData = async (endpoint: string, params: any): Promise<any> => {
  // Mevcut SAP veri çekme implementasyonunuz
  console.log('Fetching SAP data from:', endpoint, 'with params:', params);
  // API çağrısı yapılacak
  throw new Error('SAP data fetching not implemented');
};

export const sendMessageToNLP = processMessage;
--- End of sap-assist-frontend/src/services/api.ts ---

--- Start of sap-assist-frontend/src/store/authSlice.ts ---
// src/store/authSlice.ts
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { loginUser } from '../services/api';

interface AuthState {
  token: string | null;
  isAuthenticated: boolean;
  user: {
    personnelNumber: string;
    name: string;
  } | null;
  error: string | null;
}

const initialState: AuthState = {
  token: localStorage.getItem('token'),
  isAuthenticated: !!localStorage.getItem('token'),
  user: JSON.parse(localStorage.getItem('user') || 'null'),
  error: null,
};

export const login = createAsyncThunk(
  'auth/login',
  async ({ personnelNumber, password }: { personnelNumber: string; password: string }) => {
    const response = await loginUser(personnelNumber, password);
    // Store token and user info in localStorage
    localStorage.setItem('token', response.token);
    localStorage.setItem('user', JSON.stringify(response.user));
    return response;
  }
);

export const logout = createAsyncThunk('auth/logout', async () => {
  localStorage.removeItem('token');
  localStorage.removeItem('user');
});

const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(login.fulfilled, (state, action) => {
        state.token = action.payload.token;
        state.isAuthenticated = true;
        state.user = action.payload.user;
        state.error = null;
      })
      .addCase(login.rejected, (state, action) => {
        state.error = action.error.message || 'Login failed';
      })
      .addCase(logout.fulfilled, (state) => {
        state.token = null;
        state.isAuthenticated = false;
        state.user = null;
      });
  },
});

export default authSlice.reducer;
--- End of sap-assist-frontend/src/store/authSlice.ts ---

--- Start of sap-assist-frontend/src/store/index.ts ---

import { configureStore } from '@reduxjs/toolkit';
import chatReducer from './chatSlice';
import authReducer from './authSlice';

export const store = configureStore({
  reducer: {
    chat: chatReducer,
    auth: authReducer,
  },
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
--- End of sap-assist-frontend/src/store/index.ts ---

--- Start of sap-assist-frontend/src/store/chatSlice.ts ---
// sap-assist-frontend/src/store/chatSlice.ts

import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { processMessage } from '../services/api';
import { RootState } from './index';
import { Message } from '../types';

interface ChatState {
  messages: Message[];
  status: 'idle' | 'loading' | 'failed';
  error: string | null;
  context: Record<string, any>;
}

const initialState: ChatState = {
  messages: [],
  status: 'idle',
  error: null,
  context: {},
};

export const sendMessage = createAsyncThunk(
  'chat/sendMessage',
  async (message: string, { dispatch, getState }) => {
    try {
      const state = getState() as RootState;
      dispatch(chatSlice.actions.addMessage({ text: message, isUser: true }));
      
      const context = state.chat.context;
      const response = await processMessage(message, context);
      
      if (!response || !response.intent) {
        throw new Error('Invalid response from NLP service');
      }

      const newContext = { ...context, lastIntent: response.intent };
      
      return { 
        reply: response.response,
        newContext 
      };
    } catch (error) {
      console.error('Error in sendMessage:', error);
      return { 
        reply: "Üzgünüm, bir hata oluştu. Lütfen tekrar deneyin.", 
        newContext: {} 
      };
    }
  }
);

export const chatSlice = createSlice({
  name: 'chat',
  initialState,
  reducers: {
    addMessage: (state, action: PayloadAction<Message>) => {
      state.messages.push(action.payload);
    },
    clearMessages: (state) => {
      state.messages = [];
      state.error = null;
    },
    updateContext: (state, action: PayloadAction<Record<string, any>>) => {
      state.context = { ...state.context, ...action.payload };
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(sendMessage.pending, (state) => {
        state.status = 'loading';
        state.error = null;
      })
      .addCase(sendMessage.fulfilled, (state, action) => {
        state.status = 'idle';
        state.messages.push({ text: action.payload.reply, isUser: false });
        state.context = action.payload.newContext;
      })
      .addCase(sendMessage.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.error.message || 'An unknown error occurred';
        state.messages.push({ text: "Üzgünüm, bir hata oluştu. Lütfen tekrar deneyin.", isUser: false });
      });
  },
});

export const resetChat = createAsyncThunk(
  'chat/resetChat',
  async (_, { dispatch }) => {
    dispatch(chatSlice.actions.clearMessages());
    dispatch(chatSlice.actions.updateContext({}));
  }
);


export const { addMessage, clearMessages, updateContext } = chatSlice.actions;
export default chatSlice.reducer;
--- End of sap-assist-frontend/src/store/chatSlice.ts ---

--- Start of nlp/requirements.txt ---
tensorflow==2.14.0
spacy==3.4.4
transformers==4.30.0
fastapi==0.109.0
uvicorn==0.27.0.post1
httpx==0.26.0
torch==2.4.0
torchvision
torchaudio
scikit-learn
numpy==1.23.5
tqdm
nlpaug==1.1.11
nltk==3.6.7
textblob==0.17.1
transformers[torch]
flask
flask-cors==3.0.10
ray[tune]
PyJWT==2.3.0
python-dateutil==2.8.2
pandas==1.5.3
dateparser

--- End of nlp/requirements.txt ---

--- Start of nlp/__init__.py ---

--- End of nlp/__init__.py ---

--- Start of nlp/README.md ---

--- End of nlp/README.md ---

--- Start of nlp/src/__init__.py ---

--- End of nlp/src/__init__.py ---

--- Start of nlp/src/main.py ---
from nlp.src.api.server import app

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)

--- End of nlp/src/main.py ---

--- Start of nlp/src/utils/validator.py ---

# nlp/src/utils/validator.py
from datetime import datetime, timedelta
from dateutil.parser import parse


def parse_date(date):
    if isinstance(date, str):
        try:
            return datetime.strptime(date, "%d.%m.%Y").date()
        except ValueError:
            try:
                return datetime.strptime(date, "%Y-%m-%d").date()
            except ValueError:
                return None
    elif isinstance(date, datetime):
        return date.date()
    return None


def validate_date(date_str):
    if date_str is None:
        return False, "Tarih belirtilmemiş."

    try:
        parsed_date = parse(date_str, dayfirst=True).date()
    except ValueError:
        return False, "Geçersiz tarih formatı. Lütfen GG.AA.YYYY formatında bir tarih girin."

    today = datetime.now().date()
    if parsed_date < today:
        return False, "Geçmiş tarihler için izin talebi oluşturamazsınız."
    if parsed_date > today + timedelta(days=365):
        return False, "En fazla bir yıl ilerisine kadar izin talebi oluşturabilirsiniz."
    return True, None


def validate_time(time):
    if time is None:
        return True, None  # Zaman belirtilmemişse geçerli kabul ediyoruz
    # Burada gerekirse saat doğrulaması yapabilirsiniz
    return True, None


def validate_duration(duration_minutes):
    if duration_minutes is None:
        return True, None  # Süre belirtilmemişse geçerli kabul ediyoruz
    if duration_minutes <= 0:
        return False, "Süre sıfırdan büyük olmalıdır."
    if duration_minutes > 480:  # 8 saat
        return False, "Bir günde en fazla 8 saatlik izin talep edebilirsiniz."
    return True, None


def validate_leave_request(start_date, end_date, start_time, end_time, duration):
    # Tarih kontrolü
    is_valid, message = validate_date(start_date)
    if not is_valid:
        return False, message

    parsed_start_date = parse_date(start_date)
    parsed_end_date = parse_date(end_date) if end_date else parsed_start_date

    if parsed_end_date:
        is_valid, message = validate_date(end_date)
        if not is_valid:
            return False, message
        if parsed_end_date < parsed_start_date:
            return False, "Bitiş tarihi başlangıç tarihinden önce olamaz."

    # Saat kontrolü
    is_valid, message = validate_time(start_time)
    if not is_valid:
        return False, message

    is_valid, message = validate_time(end_time)
    if not is_valid:
        return False, message

    # Süre kontrolü
    is_valid, message = validate_duration(duration)
    if not is_valid:
        return False, message

    # Tarih aralığı kontrolü
    if parsed_start_date and parsed_end_date:
        date_diff = (parsed_end_date - parsed_start_date).days
        if date_diff > 30:
            return False, "En fazla 30 günlük izin talep edebilirsiniz."

    return True, None

--- End of nlp/src/utils/validator.py ---

--- Start of nlp/src/utils/entity_extraction.py ---
import spacy
import re
from datetime import datetime

nlp = spacy.load("tr_core_news_md")  # Türkçe model


def extract_entities(text):
    doc = nlp(text)
    entities = {
        "DATE": [],
        "TIME": [],
        "PERSON": [],
        "ORG": [],
    }

    for ent in doc.ents:
        if ent.label_ in entities:
            entities[ent.label_].append(ent.text)

    # Ek tarih ve saat çıkarımı
    entities["DATE"].extend(extract_dates(text))
    entities["TIME"].extend(extract_time(text))

    return entities


def extract_dates(text):
    date_pattern = r'\d{1,2}[./]\d{1,2}[./]\d{2,4}'
    dates = re.findall(date_pattern, text)
    return dates


def extract_time(text):
    time_pattern = r'\d{1,2}:\d{2}'
    times = re.findall(time_pattern, text)
    return times

--- End of nlp/src/utils/entity_extraction.py ---

--- Start of nlp/src/utils/model_utils.py ---
# nlp/src/utils/model_utils.py
import torch
from torch.utils.data import DataLoader
from sklearn.metrics import classification_report, confusion_matrix
from sklearn.model_selection import ParameterGrid, KFold
from transformers import BertForSequenceClassification
from nlp.src.utils.intent_recognition import IntentDataset
from transformers import DistilBertForSequenceClassification


def evaluate_model(model, test_loader, device):
    model.eval()
    predictions = []
    actual_labels = []

    with torch.no_grad():
        for batch in test_loader:
            input_ids = batch['input_ids'].to(device)
            attention_mask = batch['attention_mask'].to(device)
            labels = batch['labels'].to(device)

            outputs = model(input_ids, attention_mask=attention_mask)
            _, preds = torch.max(outputs.logits, dim=1)

            predictions.extend(preds.cpu().tolist())
            actual_labels.extend(labels.cpu().tolist())

    report = classification_report(
        actual_labels, predictions, output_dict=True)
    print(classification_report(actual_labels, predictions))
    print("\nConfusion Matrix:")
    print(confusion_matrix(actual_labels, predictions))

    return report['accuracy']  # Accuracy'yi döndür


def optimize_hyperparameters(X_train, y_train, X_val, y_val, tokenizer, label_dict, device):
    param_grid = {
        'learning_rate': [1e-5, 2e-5, 3e-5],
        'batch_size': [8, 16, 32],
        'num_epochs': [3, 5, 10]
    }

    best_score = 0
    best_params = None

    for params in ParameterGrid(param_grid):
        model = DistilBertForSequenceClassification.from_pretrained(
            'distilbert-base-multilingual-cased', num_labels=len(label_dict))
        model.to(device)

        train_dataset = IntentDataset(X_train, y_train, tokenizer)
        train_loader = DataLoader(
            train_dataset, batch_size=params['batch_size'], shuffle=True)

        optimizer = torch.optim.AdamW(
            model.parameters(), lr=params['learning_rate'])

        for epoch in range(params['num_epochs']):
            model.train()
            for batch in train_loader:
                optimizer.zero_grad()
                input_ids = batch['input_ids'].to(device)
                attention_mask = batch['attention_mask'].to(device)
                labels = batch['labels'].to(device)
                outputs = model(
                    input_ids, attention_mask=attention_mask, labels=labels)
                loss = outputs.loss
                loss.backward()
                optimizer.step()

        # Validasyon seti üzerinde değerlendirme
        val_dataset = IntentDataset(X_val, y_val, tokenizer)
        val_loader = DataLoader(val_dataset, batch_size=16, shuffle=False)
        val_accuracy = evaluate_model(model, val_loader, device)

        print(f"Parameters: {params}, Validation Accuracy: {val_accuracy}")

        if val_accuracy > best_score:
            best_score = val_accuracy
            best_params = params

    print(f"Best parameters: {best_params}")
    print(f"Best validation accuracy: {best_score}")
    return best_params


def cross_validate(X, y, tokenizer, label_dict, device, n_splits=5):
    kf = KFold(n_splits=n_splits, shuffle=True, random_state=42)

    fold_scores = []

    for fold, (train_index, val_index) in enumerate(kf.split(X), 1):
        X_train_fold, X_val_fold = [X[i]
                                    for i in train_index], [X[i] for i in val_index]
        y_train_fold, y_val_fold = [y[i]
                                    for i in train_index], [y[i] for i in val_index]

        model = DistilBertForSequenceClassification.from_pretrained(
            'distilbert-base-multilingual-cased', num_labels=len(label_dict))
        model.to(device)

        train_dataset = IntentDataset(X_train_fold, y_train_fold, tokenizer)
        train_loader = DataLoader(train_dataset, batch_size=16, shuffle=True)

        optimizer = torch.optim.AdamW(model.parameters(), lr=2e-5)

        for epoch in range(5):  # 5 epoch eğitim
            model.train()
            for batch in train_loader:
                optimizer.zero_grad()
                input_ids = batch['input_ids'].to(device)
                attention_mask = batch['attention_mask'].to(device)
                labels = batch['labels'].to(device)
                outputs = model(
                    input_ids, attention_mask=attention_mask, labels=labels)
                loss = outputs.loss
                loss.backward()
                optimizer.step()

        # Validasyon
        val_dataset = IntentDataset(X_val_fold, y_val_fold, tokenizer)
        val_loader = DataLoader(val_dataset, batch_size=16, shuffle=False)
        fold_score = evaluate_model(model, val_loader, device)
        fold_scores.append(fold_score)

        print(f"Fold {fold} score: {fold_score}")

    print(
        f"Average cross-validation score: {sum(fold_scores) / len(fold_scores)}")

--- End of nlp/src/utils/model_utils.py ---

--- Start of nlp/src/utils/evaluate_model.py ---
# nlp/src/utils/evaluate_model.py
from nlp.src.utils.model_training import IntentDataset
import os
import sys
import torch
from transformers import BertForSequenceClassification, BertTokenizer
from sklearn.metrics import classification_report, confusion_matrix
import pandas as pd
import pickle

# Projenin kök dizinini Python yoluna ekle
project_root = os.path.abspath(os.path.join(
    os.path.dirname(__file__), '..', '..', '..'))
sys.path.insert(0, project_root)


def evaluate_model(model, eval_dataset, device, label_encoder):
    model.eval()
    all_preds = []
    all_labels = []

    with torch.no_grad():
        for item in eval_dataset:
            inputs = {k: v.unsqueeze(0).to(device)
                      for k, v in item.items() if k != 'labels'}
            labels = item['labels'].unsqueeze(0).to(device)

            outputs = model(**inputs)
            preds = torch.argmax(outputs.logits, dim=-1)

            all_preds.extend(preds.cpu().numpy())
            all_labels.extend(labels.cpu().numpy())

    print(classification_report(all_labels, all_preds,
          target_names=label_encoder.classes_))
    print("Confusion Matrix:")
    print(confusion_matrix(all_labels, all_preds))


if __name__ == "__main__":
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    print(f"Using device: {device}")

    # Model ve tokenizer yükleme
    model = BertForSequenceClassification.from_pretrained(
        "./improved_intent_classifier_model")
    tokenizer = BertTokenizer.from_pretrained(
        "./improved_intent_classifier_model")
    model.to(device)

    # Label encoder yükleme
    with open('label_encoder.pkl', 'rb') as f:
        le = pickle.load(f)

    # Veri yükleme
    data_path = os.path.join(project_root, 'nlp', 'data',
                             'augmented_intent_data.json')
    data = pd.read_json(data_path)

    # Veri seti oluşturma
    eval_dataset = IntentDataset(data['text'], le.transform(data['intent']))

    # Değerlendirme
    evaluate_model(model, eval_dataset, device, le)

--- End of nlp/src/utils/evaluate_model.py ---

--- Start of nlp/src/utils/data_preprocessing.py ---
import re
from typing import List, Dict, Union


def preprocess_text(text: Union[str, List[str]]) -> str:
    if isinstance(text, list):
        text = ' '.join(text)  # Eğer liste ise, elemanları birleştir
    # Küçük harfe çevir
    text = text.lower()
    # Gereksiz boşlukları temizle
    text = re.sub(r'\s+', ' ', text).strip()
    # Türkçe karakterleri koru, diğer noktalama işaretlerini kaldır
    text = re.sub(r'[^a-zçğıöşüA-ZÇĞİÖŞÜ0-9\s]', '', text)
    return text


def balance_dataset(data: List[Dict[str, Union[str, List[str]]]]) -> List[Dict[str, str]]:
    intent_counts = {}
    for item in data:
        intent = item['intent']
        intent_counts[intent] = intent_counts.get(intent, 0) + 1

    max_count = max(intent_counts.values())
    balanced_data = []
    for item in data:
        intent = item['intent']
        text = item['text']
        if isinstance(text, list):
            text = text[0]  # Liste yerine ilk elemanı al
        preprocessed_text = preprocess_text(text)
        balanced_data.extend(
            [{'text': preprocessed_text, 'intent': intent}] * (max_count // intent_counts[intent]))

    return balanced_data

--- End of nlp/src/utils/data_preprocessing.py ---

--- Start of nlp/src/utils/model_training.py ---
import numpy as np
from torch.utils.data import Dataset
from transformers import AutoTokenizer, AutoModelForSequenceClassification, GPT2Tokenizer, GPT2LMHeadModel, TrainingArguments, Trainer, DataCollatorForLanguageModeling
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
import argparse
import logging
import json
import torch
import os
from torch.cuda.amp import autocast
os.environ['CUDA_VISIBLE_DEVICES'] = ''

torch.backends.mps.enabled = False

# Proje kök dizinini belirleme
PROJECT_ROOT = os.path.abspath(os.path.join(
    os.path.dirname(__file__), '..', '..', '..'))

# Logging ayarları
logging.basicConfig(level=logging.INFO,
                    format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


class IntentDataset(Dataset):
    def __init__(self, encodings, labels):
        self.encodings = encodings
        self.labels = labels

    def __getitem__(self, idx):
        item = {key: torch.tensor(val[idx])
                for key, val in self.encodings.items()}
        item['labels'] = torch.tensor(self.labels[idx])
        return item

    def __len__(self):
        return len(self.labels)


class ResponseDataset(Dataset):
    def __init__(self, encodings):
        self.encodings = encodings

    def __getitem__(self, idx):
        item = {key: torch.tensor(val[idx])
                for key, val in self.encodings.items()}
        return item

    def __len__(self):
        return len(self.encodings.input_ids)


def load_data(file_path):
    with open(file_path, 'r', encoding='utf-8') as f:
        return json.load(f)


class MixedPrecisionTrainer(Trainer):
    def training_step(self, model, inputs):
        model.train()
        inputs = self._prepare_inputs(inputs)

        with autocast():
            loss = self.compute_loss(model, inputs)

        if self.args.gradient_accumulation_steps > 1:
            loss = loss / self.args.gradient_accumulation_steps

        loss.backward()

        return loss.detach()


def train_intent_model(data_path, model_save_path):
    logger.info("Starting intent classification model training")

    # Veri yükleme
    data = load_data(data_path)
    texts = [item['text'] for item in data]
    intents = [item['intent'] for item in data]

    # Label encoding
    label_encoder = LabelEncoder()
    encoded_intents = label_encoder.fit_transform(intents)

    # Veri bölme
    train_texts, val_texts, train_labels, val_labels = train_test_split(
        texts, encoded_intents, test_size=0.2, random_state=42)

    # Tokenizer ve model yükleme
    tokenizer = AutoTokenizer.from_pretrained("dbmdz/bert-base-turkish-cased")
    model = AutoModelForSequenceClassification.from_pretrained(
        "dbmdz/bert-base-turkish-cased", num_labels=len(label_encoder.classes_))

    model.bert.encoder.layer = torch.nn.ModuleList(
        [layer.to('cpu') for layer in model.bert.encoder.layer])

    # CPU'ya taşı
    device = torch.device("cpu")
    model = model.to(device)

    # Veriyi tokenize etme
    train_encodings = tokenizer(train_texts, truncation=True, padding=True)
    val_encodings = tokenizer(val_texts, truncation=True, padding=True)

    # Dataset oluşturma
    train_dataset = IntentDataset(train_encodings, train_labels)
    val_dataset = IntentDataset(val_encodings, val_labels)

    # Eğitim ayarları
    training_args = TrainingArguments(
        output_dir=os.path.join(model_save_path, 'results'),
        num_train_epochs=5,
        per_device_train_batch_size=8,
        per_device_eval_batch_size=16,
        warmup_steps=500,
        weight_decay=0.01,
        logging_dir=os.path.join(model_save_path, 'logs'),
        logging_steps=10,
        evaluation_strategy="steps",
        eval_steps=500,
        save_steps=1000,
        load_best_model_at_end=True,
        no_cuda=True,
        fp16=True,  # Karma hassasiyet eğitimini etkinleştir
    )

    # Trainer oluşturma ve eğitim
    trainer = MixedPrecisionTrainer(
        model=model,
        args=training_args,
        train_dataset=train_dataset,
        eval_dataset=val_dataset
    )

    trainer.train()

    # Model ve tokenizer'ı kaydetme
    model.save_pretrained(model_save_path)
    tokenizer.save_pretrained(model_save_path)

    # Label encoder'ı kaydetme
    with open(os.path.join(model_save_path, 'label_encoder.json'), 'w') as f:
        json.dump(label_encoder.classes_.tolist(), f)

    logger.info(f"Intent classification model saved to {model_save_path}")


def train_response_model(data_path, model_save_path):
    logger.info("Starting response generation model training")

    # Veri yükleme
    data = load_data(data_path)

    # Veri yapısını kontrol et
    logger.info(f"Sample data item: {data[0]}")

    # Veriyi uygun formata dönüştürme
    texts = [
        f"Intent: {item['intent']}\nContext: {json.dumps(item.get('context', {}))}\nResponse: {item['response']}"
        for item in data
    ]

    # GPT-2 modelini ve tokenizer'ı yükle
    model_name = "ytu-ce-cosmos/turkish-gpt2"
    try:
        tokenizer = GPT2Tokenizer.from_pretrained(
            model_name, local_files_only=True)
        model = GPT2LMHeadModel.from_pretrained(
            model_name, local_files_only=True)
        logger.info("Model loaded from local files.")
    except OSError:
        logger.info("Local model not found. Downloading from Hugging Face.")
        tokenizer = GPT2Tokenizer.from_pretrained(model_name)
        model = GPT2LMHeadModel.from_pretrained(model_name)

    # Özel tokenleri ekle
    special_tokens_dict = {'bos_token': '<|startoftext|>',
                           'eos_token': '<|endoftext|>', 'pad_token': '<|pad|>'}
    num_added_toks = tokenizer.add_special_tokens(special_tokens_dict)
    model.resize_token_embeddings(len(tokenizer))

    # Veriyi tokenize etme
    encodings = tokenizer(texts, truncation=True, padding=True,
                          max_length=512, return_tensors="pt")

    # Dataset oluşturma
    dataset = ResponseDataset(encodings)

    # Data collator
    data_collator = DataCollatorForLanguageModeling(
        tokenizer=tokenizer, mlm=False)

    # Eğitim ayarları
    training_args = TrainingArguments(
        output_dir=os.path.join(model_save_path, 'results'),
        num_train_epochs=10,
        per_device_train_batch_size=8,
        save_steps=1000,
        save_total_limit=2,
        prediction_loss_only=True,
        no_cuda=True,
        learning_rate=5e-5,
        weight_decay=0.01,
        warmup_steps=500,
        fp16=True,  # Karma hassasiyet eğitimini etkinleştir
    )

    # Trainer oluşturma ve eğitim
    trainer = MixedPrecisionTrainer(
        model=model,
        args=training_args,
        train_dataset=dataset,
        data_collator=data_collator,
    )

    trainer.train()

    # Model ve tokenizer'ı kaydetme
    model.save_pretrained(model_save_path)
    tokenizer.save_pretrained(model_save_path)

    logger.info(f"Response generation model saved to {model_save_path}")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Train intent classification and response generation models")
    parser.add_argument('--task', type=str, required=True, choices=[
                        'intent', 'response'], help="Task to perform: 'intent' for intent classification, 'response' for response generation")
    args = parser.parse_args()

    if args.task == 'intent':
        intent_data_path = os.path.join(
            PROJECT_ROOT, 'nlp', 'data', 'intent_data.json')
        intent_model_save_path = os.path.join(
            PROJECT_ROOT, 'nlp', 'models', 'intent_classifier_model')
        train_intent_model(intent_data_path, intent_model_save_path)
    elif args.task == 'response':
        response_data_path = os.path.join(
            PROJECT_ROOT, 'nlp', 'data', 'response_data.json')
        response_model_save_path = os.path.join(
            PROJECT_ROOT, 'nlp', 'models', 'response_generator')
        train_response_model(response_data_path, response_model_save_path)

--- End of nlp/src/utils/model_training.py ---

--- Start of nlp/src/utils/nlp_utils.py ---
# nlp/src/utils/nlp_utils.py
import spacy

nlp = spacy.load("en_core_web_sm")


def tokenize(text):
    doc = nlp(text)
    return [token.text for token in doc]


def get_entities(text):
    doc = nlp(text)
    return [(ent.text, ent.label_) for ent in doc.ents]


def get_pos_tags(text):
    doc = nlp(text)
    return [(token.text, token.pos_) for token in doc]

--- End of nlp/src/utils/nlp_utils.py ---

--- Start of nlp/src/utils/__init__.py ---
from . import validator
from . import entity_extraction
from . import normalizer
--- End of nlp/src/utils/__init__.py ---

--- Start of nlp/src/utils/intent_recognition.py ---
# nlp/src/utils/intent_recognition.py
from transformers import DistilBertForSequenceClassification, AutoTokenizer
import torch
from torch.utils.data import Dataset, DataLoader
import nlpaug.augmenter.word as naw


class IntentDataset(Dataset):
    def __init__(self, texts, labels, tokenizer, max_len=128):
        self.texts = texts
        self.labels = labels
        self.tokenizer = tokenizer
        self.max_len = max_len

    def __len__(self):
        return len(self.texts)

    def __getitem__(self, item):
        text = str(self.texts[item])
        label = self.labels[item]

        encoding = self.tokenizer.encode_plus(
            text,
            add_special_tokens=True,
            max_length=self.max_len,
            return_token_type_ids=False,
            padding='max_length',
            truncation=True,
            return_attention_mask=True,
            return_tensors='pt',
        )

        return {
            'text': text,
            'input_ids': encoding['input_ids'].flatten(),
            'attention_mask': encoding['attention_mask'].flatten(),
            'labels': torch.tensor(label, dtype=torch.long)
        }


def augment_data(texts, labels, num_aug=1):
    aug = naw.SynonymAug(aug_src='wordnet')
    augmented_texts = []
    augmented_labels = []

    for text, label in zip(texts, labels):
        augmented_texts.append(text)
        augmented_labels.append(label)

        for _ in range(num_aug):
            augmented_text = aug.augment(text)
            augmented_texts.append(augmented_text)
            augmented_labels.append(label)

    return augmented_texts, augmented_labels


def train_intent_model(texts, labels, tokenizer, device, num_labels):
    dataset = IntentDataset(texts, labels, tokenizer)
    dataloader = DataLoader(dataset, batch_size=16, shuffle=True)

    model = DistilBertForSequenceClassification.from_pretrained(
        'dbmdz/distilbert-base-turkish-cased', num_labels=num_labels)
    model.to(device)

    optimizer = torch.optim.AdamW(model.parameters(), lr=2e-5)

    for epoch in range(5):  # 5 epoch eğitim
        model.train()
        for batch in dataloader:
            optimizer.zero_grad()
            input_ids = batch['input_ids'].to(device)
            attention_mask = batch['attention_mask'].to(device)
            labels = batch['labels'].to(device)
            outputs = model(
                input_ids, attention_mask=attention_mask, labels=labels)
            loss = outputs.loss
            loss.backward()
            optimizer.step()

    return model


def classify_intent(text):
    entities = extract_entities(text)
    normalized_text = ' '.join([normalize_entity(e, v)
                               for e, v in entities.items()])

    inputs = tokenizer(normalized_text, return_tensors="pt",
                       truncation=True, padding=True)

    with torch.no_grad():
        outputs = model(**inputs)

    logits = outputs.logits
    probabilities = torch.nn.functional.softmax(logits, dim=-1)
    confidence, predicted_class = torch.max(probabilities, dim=-1)
    intent = le.inverse_transform([predicted_class.item()])[0]

    return intent, confidence.item(), entities

--- End of nlp/src/utils/intent_recognition.py ---

--- Start of nlp/src/utils/data_utils.py ---
# nlp/src/utils/data_utils.py
import json
from sklearn.model_selection import train_test_split
from .intent_recognition import train_intent_model


def load_training_data(file_path):
    with open(file_path, 'r', encoding='utf-8') as f:
        data = json.load(f)

    texts = [item['text'] for item in data]
    labels = [item['intent'] for item in data]

    # Etiketleri sayısal değerlere dönüştür
    unique_labels = list(set(labels))
    label_dict = {label: i for i, label in enumerate(unique_labels)}
    numeric_labels = [label_dict[label] for label in labels]

    return texts, numeric_labels, label_dict


def update_model(new_texts, new_labels, texts, labels, label_dict, tokenizer, device):
    # Yeni veriyi mevcut veri ile birleştir
    all_texts = texts + new_texts
    all_labels = labels + new_labels

    # Veriyi karıştır ve böl
    X_train, X_test, y_train, y_test = train_test_split(
        all_texts, all_labels, test_size=0.2, random_state=42)

    # Modeli yeniden eğit
    num_labels = len(set(all_labels))
    model = train_intent_model(X_train, y_train, tokenizer, device, num_labels)

    # Modeli değerlendir ve kaydet
    # (Değerlendirme fonksiyonunu implement etmeniz gerekecek)
    # evaluate_model(model, X_test, y_test, tokenizer, device)

    return model, label_dict

--- End of nlp/src/utils/data_utils.py ---

--- Start of nlp/src/utils/chatbot.py ---
# nlp/src/utils/chatbot.py

import torch
from transformers import AutoTokenizer, BertForSequenceClassification
import pickle
from nlp.src.utils.entity_extraction import extract_entities
from nlp.src.utils.data_preprocessing import preprocess_text


class Chatbot:
    def __init__(self, model_path, label_encoder_path):
        self.device = torch.device(
            "cuda" if torch.cuda.is_available() else "cpu")
        self.tokenizer = AutoTokenizer.from_pretrained(model_path)
        self.model = BertForSequenceClassification.from_pretrained(
            model_path).to(self.device)

        with open(label_encoder_path, 'rb') as f:
            self.label_encoder = pickle.load(f)

    def classify_intent(self, text):
        normalized_text = preprocess_text(text)
        inputs = self.tokenizer(
            normalized_text, return_tensors="pt", truncation=True, padding=True).to(self.device)

        with torch.no_grad():
            outputs = self.model(**inputs)

        logits = outputs.logits
        probabilities = torch.nn.functional.softmax(logits, dim=-1)
        confidence, predicted_class = torch.max(probabilities, dim=-1)

        intent = self.label_encoder.inverse_transform(
            [predicted_class.item()])[0]
        return intent, confidence.item()

    def process_message(self, text):
        entities = extract_entities(text)
        intent, confidence = self.classify_intent(text)
        response = self.generate_response(intent, confidence, entities)

        return {
            "intent": intent,
            "confidence": confidence,
            "response": response,
            "entities": entities
        }

--- End of nlp/src/utils/chatbot.py ---

--- Start of nlp/src/utils/data_augmentation.py ---
import json
import random
from nltk.tokenize import word_tokenize
from nltk.corpus import stopwords
import nltk

nltk.download('punkt')
nltk.download('stopwords')


def load_data(file_path):
    with open(file_path, 'r', encoding='utf-8') as f:
        return json.load(f)


def save_data(data, file_path):
    with open(file_path, 'w', encoding='utf-8') as f:
        json.dump(data, f, ensure_ascii=False, indent=2)


def augment_data(data):
    augmented_data = []
    stop_words = set(stopwords.words('turkish'))

    for item in data:
        augmented_data.append(item)

        # Kelimeleri karıştırma
        words = word_tokenize(item['text'])
        words = [w for w in words if w not in stop_words]
        random.shuffle(words)
        augmented_data.append({
            'text': ' '.join(words),
            'intent': item['intent']
        })

        # Kelime ekleme/çıkarma
        if len(words) > 3:
            removed = words[:-1]
            augmented_data.append({
                'text': ' '.join(removed),
                'intent': item['intent']
            })

        # Düzeltme: Rastgele bir kelime eklemek yerine, mevcut kelimelerden birini tekrar edelim
        added = words + [random.choice(words)]
        augmented_data.append({
            'text': ' '.join(added),
            'intent': item['intent']
        })

    return augmented_data

# Test fonksiyonu


def test_augmentation():
    test_data = [
        {"text": "Merhaba nasılsınız?", "intent": "greeting"},
        {"text": "İzin almak istiyorum", "intent": "leave_request"}
    ]
    augmented = augment_data(test_data)
    print(f"Original data size: {len(test_data)}")
    print(f"Augmented data size: {len(augmented)}")
    for item in augmented:
        print(f"Text: {item['text']}, Intent: {item['intent']}")


if __name__ == "__main__":
    data = load_data('nlp/data/augmented_intent_data.json')
    augmented_data = augment_data(data)
    save_data(augmented_data, 'nlp/data/enriched_intent_data.json')
    print(f"Original data size: {len(data)}")
    print(f"Augmented data size: {len(augmented_data)}")
    test_augmentation()

--- End of nlp/src/utils/data_augmentation.py ---

--- Start of nlp/src/utils/normalizer.py ---
import re
from datetime import datetime


def normalize_date(date_string):
    """
    Farklı formatlardaki tarih girişlerini standart bir formata dönüştürür.
    Örnek: '15.07.2024', '15/07/2024', '2024-07-15' -> '2024-07-15'
    """
    if isinstance(date_string, list):
        date_string = date_string[0] if date_string else ""

    date_formats = ['%d.%m.%Y', '%d/%m/%Y', '%Y-%m-%d']
    for date_format in date_formats:
        try:
            return datetime.strptime(date_string, date_format).strftime('%Y-%m-%d')
        except ValueError:
            continue
    return date_string  # Eğer hiçbir format uymuyorsa, orijinal string'i döndür


def normalize_time(time_string):
    """
    Farklı formatlardaki saat girişlerini standart bir formata dönüştürür.
    Örnek: '14:30', '14.30', '2:30 PM' -> '14:30'
    """
    if isinstance(time_string, list):
        time_string = time_string[0] if time_string else ""

    time_formats = ['%H:%M', '%H.%M', '%I:%M %p']
    for time_format in time_formats:
        try:
            return datetime.strptime(time_string, time_format).strftime('%H:%M')
        except ValueError:
            continue
    return time_string  # Eğer hiçbir format uymuyorsa, orijinal string'i döndür


def normalize_duration(duration_string):
    """
    Süre girişlerini dakika cinsinden standart bir formata dönüştürür.
    Örnek: '2 saat', '2h', '120 dakika', '120m' -> 120
    """
    if isinstance(duration_string, list):
        duration_string = duration_string[0] if duration_string else ""

    duration_pattern = r'(\d+)\s*(saat|h|dakika|m)'
    match = re.match(duration_pattern, duration_string, re.IGNORECASE)
    if match:
        value, unit = match.groups()
        if unit.lower() in ['saat', 'h']:
            return int(value) * 60
        else:
            return int(value)
    return duration_string  # Eğer pattern uymuyorsa, orijinal string'i döndür


def normalize_entity(entity_type, value):
    if isinstance(value, list):
        return ' '.join([str(v) for v in value if v is not None])
    return str(value) if value is not None else ''

--- End of nlp/src/utils/normalizer.py ---

--- Start of nlp/src/utils/hyperparameter_tuning.py ---
# nlp/src/utils/hyperparameter_tuning.py
import pickle
import os
import sys
import torch
from transformers import BertTokenizer, BertForSequenceClassification, Trainer, TrainingArguments
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
import pandas as pd
import numpy as np
from sklearn.metrics import accuracy_score, precision_recall_fscore_support

# Projenin kök dizinini Python yoluna ekle
project_root = os.path.abspath(os.path.join(
    os.path.dirname(__file__), '..', '..', '..'))
sys.path.insert(0, project_root)

# CPU kullanımını zorla
os.environ["CUDA_VISIBLE_DEVICES"] = ""
device = torch.device("cpu")
print(f"Using device: {device}")

# Veri yükleme
data_path = os.path.join(project_root, 'nlp', 'data',
                         'augmented_intent_data.json')
data = pd.read_json(data_path)

# Etiket kodlama
le = LabelEncoder()
data['label'] = le.fit_transform(data['intent'])

# Veri bölme
train_texts, val_texts, train_labels, val_labels = train_test_split(
    data['text'], data['label'], test_size=0.2, stratify=data['label'], random_state=42)

# Tokenizer ve model yükleme
tokenizer = BertTokenizer.from_pretrained('dbmdz/bert-base-turkish-cased')
model = BertForSequenceClassification.from_pretrained(
    'dbmdz/bert-base-turkish-cased', num_labels=len(le.classes_))
model.to(device)

# Veri seti oluşturma


class IntentDataset(torch.utils.data.Dataset):
    def __init__(self, texts, labels, tokenizer, max_length=128):
        self.texts = texts
        self.labels = labels
        self.tokenizer = tokenizer
        self.max_length = max_length

    def __len__(self):
        return len(self.texts)

    def __getitem__(self, idx):
        text = str(self.texts.iloc[idx])
        label = self.labels.iloc[idx]

        encoding = self.tokenizer.encode_plus(
            text,
            add_special_tokens=True,
            max_length=self.max_length,
            return_token_type_ids=False,
            padding='max_length',
            truncation=True,
            return_attention_mask=True,
            return_tensors='pt',
        )

        return {
            'input_ids': encoding['input_ids'].flatten(),
            'attention_mask': encoding['attention_mask'].flatten(),
            'labels': torch.tensor(label, dtype=torch.long)
        }


train_dataset = IntentDataset(train_texts, train_labels, tokenizer)
val_dataset = IntentDataset(val_texts, val_labels, tokenizer)

# Metrik hesaplama fonksiyonu


def compute_metrics(pred):
    labels = pred.label_ids
    preds = pred.predictions.argmax(-1)
    precision, recall, f1, _ = precision_recall_fscore_support(
        labels, preds, average='weighted')
    acc = accuracy_score(labels, preds)
    return {
        'accuracy': acc,
        'f1': f1,
        'precision': precision,
        'recall': recall
    }


# Eğitim argümanları
training_args = TrainingArguments(
    output_dir='./results',
    num_train_epochs=5,
    per_device_train_batch_size=16,
    per_device_eval_batch_size=64,
    warmup_steps=500,
    weight_decay=0.01,
    logging_dir='./logs',
    logging_steps=10,
    evaluation_strategy="epoch",
    save_strategy="epoch",
    load_best_model_at_end=True,
    metric_for_best_model="f1",
    no_cuda=True,  # GPU kullanımını devre dışı bırak
)

# Trainer oluşturma ve eğitim
trainer = Trainer(
    model=model,
    args=training_args,
    train_dataset=train_dataset,
    eval_dataset=val_dataset,
    compute_metrics=compute_metrics,
)

trainer.train()

# Model kaydetme
model.save_pretrained("./improved_intent_classifier_model")
tokenizer.save_pretrained("./improved_intent_classifier_model")

# Label encoder kaydetme
with open('label_encoder.pkl', 'wb') as f:
    pickle.dump(le, f)

print("Improved model and label encoder saved.")

--- End of nlp/src/utils/hyperparameter_tuning.py ---

--- Start of nlp/src/models/response_generator.py ---
# nlp/src/models/response_generator.py

from transformers import AutoTokenizer, AutoModelForCausalLM


class ResponseGenerator:
    def __init__(self, model_path="dbmdz/german-gpt2"):  # Use an appropriate Turkish GPT model
        self.tokenizer = AutoTokenizer.from_pretrained(model_path)
        self.model = AutoModelForCausalLM.from_pretrained(model_path)

    def generate(self, intent, entities, context):
        input_text = f"Intent: {intent}\nEntities: {entities}\nContext: {context}\nResponse:"
        inputs = self.tokenizer(
            input_text, return_tensors="pt", truncation=True, padding=True)

        outputs = self.model.generate(
            **inputs,
            max_length=150,
            num_return_sequences=1,
            no_repeat_ngram_size=2,
            do_sample=True,
            top_k=50,
            top_p=0.95,
            temperature=0.7
        )

        response = self.tokenizer.decode(outputs[0], skip_special_tokens=True)
        return response

    def train(self, train_data):
        # Implement fine-tuning logic here
        pass

    def save(self, path):
        self.model.save_pretrained(path)
        self.tokenizer.save_pretrained(path)

    def load(self, path):
        self.model = AutoModelForCausalLM.from_pretrained(path)
        self.tokenizer = AutoTokenizer.from_pretrained(path)

--- End of nlp/src/models/response_generator.py ---

--- Start of nlp/src/models/intent_classifier.py ---
import torch
from transformers import BertTokenizer, BertForSequenceClassification
import pickle
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class IntentClassifier:
    def __init__(self, model_path):
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        self.model = BertForSequenceClassification.from_pretrained(model_path)
        self.model.to(self.device)
        self.tokenizer = BertTokenizer.from_pretrained(model_path)
        
        with open(f"{model_path}/label_encoder.pkl", "rb") as f:
            self.label_encoder = pickle.load(f)

    def predict(self, text):
        self.model.eval()
        inputs = self.tokenizer(text, return_tensors="pt", truncation=True, padding=True).to(self.device)
        
        with torch.no_grad():
            outputs = self.model(**inputs)
        
        logits = outputs.logits
        probabilities = torch.nn.functional.softmax(logits, dim=-1)
        predicted_class = torch.argmax(probabilities, dim=-1).item()
        confidence = probabilities[0][predicted_class].item()

        intent = self.label_encoder.inverse_transform([predicted_class])[0]
        
        return intent, confidence
--- End of nlp/src/models/intent_classifier.py ---

--- Start of nlp/src/models/entity_extractor.py ---
# nlp/src/models/entity_extractor.py

import spacy
import logging

logger = logging.getLogger(__name__)


class EntityExtractor:
    def __init__(self, model_name="tr_core_news_md"):
        try:
            self.nlp = spacy.load(model_name)
            logger.info(f"Successfully loaded SpaCy model: {model_name}")
        except IOError as e:
            logger.error(f"Couldn't load {model_name}. Error: {str(e)}")
            raise IOError(
                f"Couldn't load {model_name}. Make sure it's installed: pip install https://huggingface.co/turkish-nlp-suite/tr_core_news_md/resolve/main/tr_core_news_md-1.0-py3-none-any.whl")

    def extract(self, text):
        try:
            doc = self.nlp(text)
            entities = {}
            for ent in doc.ents:
                if ent.label_ not in entities:
                    entities[ent.label_] = []
                entities[ent.label_].append(ent.text)
            return entities
        except Exception as e:
            logger.error(f"Error during entity extraction: {str(e)}")
            return {}

    def train(self, train_data):
        # Implement training logic here if needed
        logger.info("Training method called, but not implemented yet.")
        pass

    def save(self, path):
        try:
            self.nlp.to_disk(path)
            logger.info(f"Model saved to {path}")
        except Exception as e:
            logger.error(f"Error saving model: {str(e)}")

    def load(self, path):
        try:
            self.nlp = spacy.load(path)
            logger.info(f"Model loaded from {path}")
        except Exception as e:
            logger.error(f"Error loading model: {str(e)}")
            raise IOError(f"Couldn't load model from {path}. Error: {str(e)}")

--- End of nlp/src/models/entity_extractor.py ---

--- Start of nlp/src/api/server.py ---
# nlp/src/api/server.py

from nlp.src.utils.chatbot import Chatbot
from flask import Flask, request, jsonify
import sys
import os

# Projenin kök dizinini Python yoluna ekle
project_root = os.path.abspath(os.path.join(
    os.path.dirname(__file__), '..', '..', '..'))
sys.path.insert(0, project_root)


app = Flask(__name__)


def initialize_chatbot():
    model_path = os.path.join(
        project_root, 'nlp', 'models', 'intent_classifier_model')
    le_path = os.path.join(project_root, 'nlp', 'models', 'label_encoder.pkl')
    return Chatbot(model_path, le_path)


chatbot = initialize_chatbot()


@app.route('/classify', methods=['POST'])
def classify():
    app.logger.debug(f"Received request: {request.json}")
    data = request.get_json()
    if not data or 'text' not in data:
        app.logger.error("Invalid request payload")
        return jsonify({"error": "Invalid request payload"}), 400

    user_input = data['text']
    try:
        result = chatbot.process_message(user_input)
        app.logger.debug(f"Sending response: {result}")
        return jsonify(result)
    except Exception as e:
        app.logger.error(f"Error processing message: {str(e)}")
        return jsonify({"error": "Error processing message"}), 500


if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)

--- End of nlp/src/api/server.py ---

--- Start of nlp/src/api/__init__.py ---

--- End of nlp/src/api/__init__.py ---
